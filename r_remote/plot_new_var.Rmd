---
title: "plot genotype, phenotype and effect size data"
author: "Andrea Chen"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
setwd("/workdir/zc524/collective_behavior_evo/r_remote")
base_data_folder <- "../data/new_variance"
base_plot_folder <- "../r_plots/new_var_plots2"
target_beta <- c(0.0, 0.01, 0.03, 0.05, 0.07, 0.3, 0.5, 0.7, 0.9, 1.0)
regimes <- c("inv", "var")  # "inv" = inverse_variance, "var" = variance
```

# load GENOTYPE data
```{r}
# Set the top-level folder
folder <- paste0(base_data_folder, "/genotype")

# List all .tsv files recursively
file_list <- list.files(
  path = folder,
  pattern = "\\.tsv$",
  full.names = TRUE,
  recursive = TRUE
)

# Function to extract metadata from path
# Matches: genotype/n_<n>_beta_<beta>_sz_<sz>_reg_<inv|var>_<rep>.tsv
extract_geno_metadata <- function(path) {
  pat <- "genotype/n_(\\d+)_beta_(-?[0-9.]+)_sz_(\\d+)_reg_(inv|var)_(\\d+)\\.tsv"
  matches <- regexec(pat, path)
  parts <- regmatches(path, matches)[[1]]

  if (length(parts) != 6) {
    warning("Could not extract metadata from path: ", path,
            " with matches: ", paste(parts, collapse = ", "))
    return(data.frame())
  }

  data.frame(
    n    = as.integer(parts[2]),
    beta  = as.numeric(parts[3]),
    sz   = as.integer(parts[4]),
    reg  = parts[5],             # "ave" or "fit"
    rep  = as.integer(parts[6]),
    stringsAsFactors = FALSE
  )
}

# Helper: get shift_size from the companion "data" file (optimum at generation == 10001)
get_shift_from_data <- function(geno_file, base_data_folder, opt_gen = 10001L) {
  # Mirror the path: .../genotype/... -> .../data/...
  data_path <- sub("/genotype/", "/data/", geno_file, fixed = TRUE)
  if (!file.exists(data_path)) {
    data_path <- file.path(base_data_folder, "data", basename(geno_file))
  }

  if (!file.exists(data_path)) {
    warning("Data file not found for ", basename(geno_file), " (looked for: ", data_path, ")")
    return(NA_real_)
  }

  d <- tryCatch(read.table(data_path, header = TRUE, sep = "\t"), error = function(e) NULL)
  if (is.null(d)) {
    warning("Failed to read data file: ", data_path)
    return(NA_real_)
  }
  if (!("tick" %in% names(d)) || !("optimum" %in% names(d))) {
    warning("Missing 'tick' or 'optimum' column in data file: ", data_path)
    return(NA_real_)
  }

  row10001 <- d[d$tick == opt_gen, , drop = FALSE]
  if (nrow(row10001) < 1) {
    warning("No row with tick == ", opt_gen, " in ", data_path)
    return(NA_real_)
  }

  val <- suppressWarnings(as.numeric(row10001$optimum[1]))
  if (!is.finite(val)) {
    warning("Non-numeric 'optimum' at generation ", opt_gen, " in ", data_path)
    return(NA_real_)
  }
  val
}

# Read and combine all files
opt_gen <- 10001L
genotype_df <- do.call(rbind, lapply(file_list, function(file) {
  df <- tryCatch(read.table(file, header = TRUE, sep = "\t"), error = function(e) NULL)
  if (is.null(df)) {
    warning("Failed to read genotype file: ", file)
    return(NULL)
  }

  meta <- extract_geno_metadata(file)
  if (nrow(meta) == 0) return(NULL)

  # Attach metadata
  df$rep        <- meta$rep
  df$beta        <- meta$beta
  df$n          <- meta$n
  df$reg        <- meta$reg        # <- new column ("ave" or "fit")
  df$sz_orig    <- meta$sz         # preserve original sz
  df$shift_size <- if (meta$sz == 0L) get_shift_from_data(file, base_data_folder, opt_gen) else meta$sz
  df$file_id    <- basename(file)
  df
}))

```

# plot GENOTYPE histogram
```{r}
library(RColorBrewer)
# Assuming you want to focus on a specific generation (e.g., 10100)
target_gen <- 9999
df <- subset(genotype_df, generation == target_gen)

# Define histogram bins
num_bins <- 80
bin_breaks <- seq(-40, 40, length.out = num_bins + 1)
bin_mids <- 0.5 * (head(bin_breaks, -1) + tail(bin_breaks, -1))

# Color setup
beta_vals <- target_beta
colors <- rainbow(length(beta_vals))
names(colors) <- as.character(beta_vals)
```

## plot average GENOTYPE for each beta
```{r}
# Assumes genotype_df already has: generation, n, beta, rep, shift_size, sz_orig, reg, X* columns
# Also assumes you have: target_gen, num_bins, bin_breaks, bin_mids, base_plot_folder, regimes

avg_curve_for_subset <- function(df_block) {
  # df_block is already filtered to a single (panel × beta × reg) subset at target_gen
  if (nrow(df_block) == 0) return(rep(NA_real_, length(bin_mids)))
  counts_mat <- matrix(NA_real_, nrow = nrow(df_block), ncol = length(bin_mids))
  x_cols <- grep("^X", names(df_block))
  for (i in seq_len(nrow(df_block))) {
    vals <- suppressWarnings(as.numeric(as.vector(unlist(df_block[i, x_cols]))))
    vals <- vals[is.finite(vals)]
    if (length(vals) == 0) next
    h <- hist(vals, breaks = bin_breaks, plot = FALSE)
    if (sum(h$counts) == 0) next
    counts_mat[i, ] <- h$counts / sum(h$counts)
  }
  colMeans(counts_mat, na.rm = TRUE)
}

for (reg_lab in c("inv")) {
  df_reg_all <- subset(genotype_df, generation == target_gen & reg == reg_lab)
  if (nrow(df_reg_all) == 0) next

  for (n_val in sort(unique(df_reg_all$n))) {
    df_n <- subset(df_reg_all, n == n_val)
    if (nrow(df_n) == 0) next

    # Panels: one pooled panel for sz_orig==0, plus one per unique nonzero shift_size
    has_sz0 <- any(df_n$sz_orig == 0, na.rm = TRUE)
    shift_levels_nonzero <- sort(unique(df_n$shift_size[df_n$sz_orig != 0]))
    panel_keys <- c(if (has_sz0) "pooled_sz0" else character(0),
                    paste0("shift=", shift_levels_nonzero))

    # Colors for beta (consistent across all panels in this n & reg)
    beta_all <- sort(unique(df_n$beta))
    colors <- hcl.colors(length(beta_all), palette = "Zissou 1")
    names(colors) <- as.character(beta_all)

    # Compute common ylim across panels (max_y)
    max_y <- 0
    for (pk in panel_keys) {
      df_panel <- if (pk == "pooled_sz0") {
        subset(df_n, sz_orig == 0)
      } else {
        sh <- as.numeric(sub("shift=", "", pk))
        subset(df_n, sz_orig != 0 & shift_size == sh)
      }
      for (beta_val in beta_all) {
        avg_counts <- avg_curve_for_subset(subset(df_panel, beta == beta_val))
        max_y <- max(max_y, avg_counts, na.rm = TRUE)
      }
    }
    if (!is.finite(max_y) || max_y <= 0) max_y <- 1

    # Layout
    K <- length(panel_keys)
    ncol <- ceiling(sqrt(K))
    nrow <- ceiling(K / ncol)
    png_w <- 900 * ncol
    png_h <- 700 * nrow

    out_folder <- file.path(base_plot_folder, "genotype")
    if (!dir.exists(out_folder)) dir.create(out_folder, recursive = TRUE)
    out_path <- file.path(
      out_folder,
      paste0("/genotype_hist_avg_reg_", reg_lab, "_n_", n_val, "_gen_", target_gen, ".png")
    )
    png(out_path, width = png_w, height = png_h)
    op <- par(mfrow = c(nrow, ncol), mar = c(4, 4, 3.5, 1) + 0.1)

    for (pk in panel_keys) {
      df_panel <- if (pk == "pooled_sz0") {
        subset(df_n, sz_orig == 0)
      } else {
        sh <- as.numeric(sub("shift=", "", pk))
        subset(df_n, sz_orig != 0 & shift_size == sh)
      }

      # Title text
      panel_title <- if (pk == "pooled_sz0") {
        paste0("reg = ", reg_lab, " | n = ", n_val, " | sz=0 pooled (data-driven)")
      } else {
        paste0("reg = ", reg_lab, " | n = ", n_val, " | ", pk)
      }

      plot(NULL,
           xlim = range(bin_breaks), ylim = c(0, max_y),
           xlab = "Genotype Value", ylab = "Proportion",
           main = panel_title)
      curve(dnorm(x, mean = 0, sd = sqrt(2000)),
              add = TRUE, col = "black", lty = 2, lwd = 2)

      # Draw average curves per beta
      present_betas <- intersect(beta_all, sort(unique(df_panel$beta)))
      for (beta_val in present_betas) {
        avg_counts <- avg_curve_for_subset(subset(df_panel, beta == beta_val))
        if (all(is.na(avg_counts))) next
        lines(bin_mids, avg_counts, col = colors[as.character(beta_val)], lwd = 2)
      }

      legend("topright",
             legend = paste0("beta=", present_betas),
             col = colors[as.character(present_betas)],
             lty = 1, lwd = 2, cex = 0.8, bg = "white")
    }

    par(op)
    dev.off()
  }
}


```


# PLOT GENOTYPE OVER TIME
```{r}
# ---------------------------------------------
# Multi-panel by beta (GENOTYPE) with gen-specific bins
# Split by `reg` (values in `regimes`)
# ---------------------------------------------
.compute_center <- function(df_block) {
  xcols <- grep("^X", names(df_block))
  if (!length(xcols) || nrow(df_block) == 0) return(NA_real_)
  vals <- suppressWarnings(as.numeric(unlist(df_block[, xcols])))
  vals <- vals[is.finite(vals)]
  if (!length(vals)) return(NA_real_)
  mean(vals)
}

.avg_hist_curve_with_breaks <- function(df_block, breaks, num_bins) {
  if (nrow(df_block) == 0) return(rep(NA_real_, num_bins))
  xcols <- grep("^X", names(df_block))
  reps  <- sort(unique(df_block$rep))
  if (!length(xcols) || !length(reps)) return(rep(NA_real_, num_bins))
  counts_mat <- matrix(NA_real_, nrow = length(reps), ncol = num_bins)
  for (i in seq_along(reps)) {
    row_i <- subset(df_block, rep == reps[i])[1, ]
    vals <- suppressWarnings(as.numeric(as.vector(unlist(row_i[, xcols]))))
    vals <- vals[is.finite(vals)]
    if (!length(vals)) next
    h <- hist(vals, breaks = breaks, plot = FALSE)
    if (sum(h$counts) == 0) next
    counts_mat[i, ] <- h$counts / sum(h$counts)
  }
  colMeans(counts_mat, na.rm = TRUE)
}

plot_genotype_multi_by_beta <- function(genotype_df,
                                       out_subfolder = "genotype_multi_by_beta_genbins",
                                       gen_seq = 10000:10005,
                                       num_bins = num_bins,
                                       bin_width = bin_width,
                                       half_span = half_span,
                                       regimes = regimes) {   # <--- added
  gen_cols <- hcl.colors(length(gen_seq), palette = "Berlin")
  names(gen_cols) <- as.character(gen_seq)

  if (!("sz_orig" %in% names(genotype_df))) {
    stop("genotype_df must include sz_orig (original sz) to pool data-driven shift runs.")
  }

  # Loop over regimes
  for (reg_lab in regimes) {
    df_reg <- subset(genotype_df, reg == reg_lab)
    if (nrow(df_reg) == 0) next

    # Separate subfolder per regime
    out_dir <- file.path(base_plot_folder, out_subfolder, paste0("reg_", reg_lab))
    if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

    for (n_val in sort(unique(df_reg$n))) {
      df_n <- subset(df_reg, n == n_val)
      if (nrow(df_n) == 0) next

      has_sz0 <- any(df_n$sz_orig == 0, na.rm = TRUE)
      nonzero_shifts <- sort(unique(df_n$shift_size[df_n$sz_orig != 0]))
      shift_keys <- c(if (has_sz0) "pooled_sz0" else character(0),
                      if (length(nonzero_shifts)) paste0("shift=", nonzero_shifts) else character(0))

      all_betas <- sort(unique(df_n$beta))

      for (sk in shift_keys) {
        df_group <- if (sk == "pooled_sz0") {
          subset(df_n, sz_orig == 0)
        } else {
          sh <- as.numeric(sub("shift=", "", sk))
          subset(df_n, sz_orig != 0 & shift_size == sh)
        }
        if (nrow(df_group) == 0) next

        # Common y-limit and x-range across all beta & gens
        max_y <- 0
        x_min <- Inf; x_max <- -Inf
        for (beta_val in all_betas) {
          df_p <- subset(df_group, beta == beta_val)
          if (nrow(df_p) == 0) next
          present_gens <- intersect(gen_seq, sort(unique(df_p$generation)))
          for (g in present_gens) {
            df_pg <- subset(df_p, generation == g)
            center <- .compute_center(df_pg)
            if (!is.finite(center)) next
            breaks_g <- seq(center - half_span, center + half_span, by = bin_width)
            avg_counts <- .avg_hist_curve_with_breaks(df_pg, breaks_g, num_bins)
            max_y <- max(max_y, avg_counts, na.rm = TRUE)
            x_min <- min(x_min, min(breaks_g), na.rm = TRUE)
            x_max <- max(x_max, max(breaks_g), na.rm = TRUE)
          }
        }
        if (!is.finite(max_y) || max_y <= 0) max_y <- 1
        if (!is.finite(x_min) || !is.finite(x_max) || x_min >= x_max) {
          x_min <- -half_span; x_max <- half_span
        }

        # Layout
        K <- length(all_betas)
        ncol <- ceiling(sqrt(K))
        nrow <- ceiling(K / ncol)
        png_w <- 900 * ncol
        png_h <- 700 * nrow

        # Overall title: do NOT average across beta
        title_suffix <- if (sk == "pooled_sz0") {
          "pooled sz=0 (per-beta avg shift shown in panels)"
        } else {
          sh <- as.numeric(sub("shift=", "", sk))
          paste0("shift_size = ", sh)
        }

        out_name <- paste0(
          "genotype_multi_by_beta_reg_", reg_lab, "_n_", n_val, "_",
          gsub("[ =]", "", title_suffix), ".png"
        )
        png(file.path(out_dir, out_name), width = png_w, height = png_h)
        op <- par(mfrow = c(nrow, ncol), mar = c(4, 4, 3, 1) + 0.1, oma = c(0, 0, 3.5, 0))

        for (beta_val in all_betas) {
          df_p <- subset(df_group, beta == beta_val)

          # Panel title: if pooled sz=0, show per-beta mean shift_size
          panel_title <- if (sk == "pooled_sz0") {
            mbeta <- mean(df_p$shift_size, na.rm = TRUE)
            if (!is.finite(mbeta)) mbeta <- NA_real_
            paste0("beta = ", beta_val, " | avg shift_size = ",
                   if (is.na(mbeta)) "NA" else formatC(mbeta, format = "f", digits = 3))
          } else {
            paste0("beta = ", beta_val)
          }

          plot(NULL,
               xlim = c(x_min, x_max), ylim = c(0, max_y),
               xlab = "Genotype Value", ylab = "Proportion",
               main = panel_title)
          
          curve(dnorm(x, mean = sh, sd = sqrt(2000)),
              add = TRUE, col = "black", lty = 2, lwd = 2)

          present_gens <- intersect(gen_seq, sort(unique(df_p$generation)))
          for (g in present_gens) {
            df_pg <- subset(df_p, generation == g)
            center <- .compute_center(df_pg)
            if (!is.finite(center)) next
            breaks_g <- seq(center - half_span, center + half_span, by = bin_width)
            mids_g   <- 0.5 * (breaks_g[-length(breaks_g)] + breaks_g[-1])
            avg_counts <- .avg_hist_curve_with_breaks(df_pg, breaks_g, num_bins)
            if (all(is.na(avg_counts))) next
            lines(mids_g, avg_counts, col = gen_cols[as.character(g)], lwd = 2)
          }

          legend("topright",
                 legend = paste0("gen ", present_gens),
                 col = gen_cols[as.character(present_gens)],
                 lty = 1, lwd = 2, cex = 0.8, bg = "white")
        }

        mtext(paste0("Genotype distributions (gen-specific bins) | reg = ", reg_lab,
                     " | n = ", n_val, " | ", title_suffix),
              outer = TRUE, cex = 1.1, line = 1.2)

        par(op)
        dev.off()
      }
    }
  }
}

num_bins <- 100
bin_breaks <- seq(-50, 50, length.out = num_bins + 1)

# Derive a constant bin width from your reference breaks
bin_width <- (max(bin_breaks) - min(bin_breaks)) / num_bins
half_span <- (num_bins * bin_width) / 2

# ---- Run ----
plot_genotype_multi_by_beta(
  genotype_df,
  # out_subfolder = "genotype_overtime_10000:10005",
  # gen_seq = seq(10000, 10005, by = 1),
  # out_subfolder = "genotype_overtime_10000:10010",
  # gen_seq = seq(10000, 10010, by = 2),
  # out_subfolder = "genotype_overtime_10010:10100",
  # gen_seq = seq(10010, 10100, by = 5),
  out_subfolder = "genotype_overtime_10000:10100",
  gen_seq = seq(10000, 10100, by = 10),
  num_bins = num_bins,
  bin_width = bin_width,
  half_span = half_span,
  regimes = c("inv")
)

```


# load PHENOTYPE data
```{r}
pheno_folder <- file.path(base_data_folder, "phenotype")

# List all phenotype files
pheno_files <- list.files(
  path = pheno_folder,
  pattern = "\\.tsv$",
  full.names = TRUE,
  recursive = TRUE
)

# Parse metadata from phenotype file path
# Matches: phenotype/n_<n>_beta_<beta>_sz_<sz>_reg_<inv|var>_<rep>.tsv
extract_pheno_metadata <- function(path) {
  m <- regexec("phenotype/n_(\\d+)_beta_(-?[0-9.]+)_sz_(\\d+)_reg_(inv|var)_(\\d+)\\.tsv", path)
  parts <- regmatches(path, m)[[1]]
  if (length(parts) != 6) {
    warning("Could not extract metadata from path: ", path, " parts: ", paste(parts, collapse=", "))
    return(data.frame())
  }
  data.frame(
    n   = as.integer(parts[2]),
    beta = as.numeric(parts[3]),
    sz  = as.integer(parts[4]),
    reg = parts[5],                 # "ave" or "fit"
    rep = as.integer(parts[6]),
    stringsAsFactors = FALSE
  )
}

# Get shift_size from companion "data" file (optimum at generation == 10001)
pheno_get_shift_from_data <- function(pheno_file, base_data_folder, opt_gen = 10001L) {
  # Mirror .../phenotype/... -> .../data/...
  data_path <- sub("/phenotype/", "/data/", pheno_file, fixed = TRUE)
  if (!file.exists(data_path)) {
    data_path <- file.path(base_data_folder, "data", basename(pheno_file))
  }
  if (!file.exists(data_path)) {
    warning("Data file not found for ", basename(pheno_file), " (looked for: ", data_path, ")")
    return(NA_real_)
  }

  d <- tryCatch(read.table(data_path, header = TRUE, sep = "\t"), error = function(e) NULL)
  if (is.null(d)) {
    warning("Failed to read data file: ", data_path)
    return(NA_real_)
  }
  if (!all(c("tick", "optimum") %in% names(d))) {
    warning("Missing 'tick' or 'optimum' in data file: ", data_path)
    return(NA_real_)
  }

  row10001 <- d[d$tick == opt_gen, , drop = FALSE]
  if (nrow(row10001) < 1) {
    warning("No row with tick == ", opt_gen, " in ", data_path)
    return(NA_real_)
  }

  val <- suppressWarnings(as.numeric(row10001$optimum[1]))
  if (!is.finite(val)) {
    warning("Non-numeric 'optimum' at generation ", opt_gen, " in ", data_path)
    return(NA_real_)
  }
  val
}

# -------- Load phenotype_df (no name collisions with genotype) --------
opt_gen <- 10001L
phenotype_df <- do.call(rbind, lapply(pheno_files, function(file) {
  df <- tryCatch(read.table(file, header = TRUE, sep = "\t"), error = function(e) NULL)
  if (is.null(df)) {
    warning("Failed to read phenotype file: ", file)
    return(NULL)
  }

  meta <- extract_pheno_metadata(file)
  if (nrow(meta) == 0) return(NULL)

  # Attach metadata (distinct columns; keep original sz for pooling)
  df$rep        <- meta$rep
  df$beta        <- meta$beta
  df$n          <- meta$n
  df$reg        <- meta$reg          # <- new column ("ave" or "fit")
  df$sz_orig    <- meta$sz
  df$shift_size <- if (meta$sz == 0L) pheno_get_shift_from_data(file, base_data_folder, opt_gen) else meta$sz
  df$file_id    <- basename(file)
  df
}))

```

# plot PHENOTYPE histogram 
```{r}
# Assuming you want to focus on a specific generation (e.g., 10100)
target_gen <- 9999
df <- subset(phenotype_df, generation == target_gen)

# Define histogram bins
num_bins <- 400
bin_breaks <- seq(-200, 200, length.out = num_bins + 1)
bin_mids <- 0.5 * (head(bin_breaks, -1) + tail(bin_breaks, -1))

# Color setup
beta_vals <- target_beta
colors <- rainbow(length(beta_vals))
names(colors) <- as.character(beta_vals)
```

## plot average PHENOTYPE histogram for each beta
```{r}
avg_curve_for_subset_pheno <- function(df_block, bin_breaks, bin_mids) {
  if (nrow(df_block) == 0) return(rep(NA_real_, length(bin_mids)))
  counts_mat <- matrix(NA_real_, nrow = nrow(df_block), ncol = length(bin_mids))
  x_cols <- grep("^X", names(df_block))
  for (i in seq_len(nrow(df_block))) {
    vals <- suppressWarnings(as.numeric(as.vector(unlist(df_block[i, x_cols]))))
    vals <- vals[is.finite(vals)]
    if (length(vals) == 0) next
    h <- hist(vals, breaks = bin_breaks, plot = FALSE)
    if (sum(h$counts) == 0) next
    counts_mat[i, ] <- h$counts / sum(h$counts)
  }
  colMeans(counts_mat, na.rm = TRUE)
}

# ---- Split by regime ----
for (reg_lab in c("var")) {
  df_reg <- subset(phenotype_df, generation == target_gen & reg == reg_lab)
  if (nrow(df_reg) == 0) next

  out_dir <- file.path(base_plot_folder, paste0("phenotype"))
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

  # Pool all sz_orig == 0 together; other panels by shift_size (nonzero)
  for (n_val in sort(unique(df_reg$n))) {
    df_n <- subset(df_reg, n == n_val)
    if (nrow(df_n) == 0) next

    has_sz0 <- any(df_n$sz_orig == 0, na.rm = TRUE)
    shift_levels_nonzero <- sort(unique(df_n$shift_size[df_n$sz_orig != 0]))
    panel_keys <- c(if (has_sz0) "pooled_sz0" else character(0),
                    paste0("shift=", shift_levels_nonzero))

    # Consistent beta colors across this n (within this reg)
    beta_all <- sort(unique(df_n$beta))
    beta_cols <- hcl.colors(length(beta_all), palette = "Zissou 1")
    names(beta_cols) <- as.character(beta_all)

    # Common ylim across panels
    max_y <- 0
    for (pk in panel_keys) {
      df_panel <- if (pk == "pooled_sz0") {
        subset(df_n, sz_orig == 0)
      } else {
        sh <- as.numeric(sub("shift=", "", pk))
        subset(df_n, sz_orig != 0 & shift_size == sh)
      }
      for (beta_val in beta_all) {
        avg_counts <- avg_curve_for_subset_pheno(subset(df_panel, beta == beta_val), bin_breaks, bin_mids)
        max_y <- max(max_y, avg_counts, na.rm = TRUE)
      }
    }
    if (!is.finite(max_y) || max_y <= 0) max_y <- 1

    # Layout
    K <- length(panel_keys)
    ncol <- ceiling(sqrt(K))
    nrow <- ceiling(K / ncol)
    png_w <- 900 * ncol
    png_h <- 700 * nrow

    out_path <- file.path(out_dir, paste0("phenotype_hist_avg_reg_", reg_lab,
                                          "_n_", n_val, "_gen_", target_gen, ".png"))
    png(out_path, width = png_w, height = png_h)
    op <- par(mfrow = c(nrow, ncol), mar = c(4, 4, 3.5, 1) + 0.1)

    for (pk in panel_keys) {
      df_panel <- if (pk == "pooled_sz0") {
        subset(df_n, sz_orig == 0)
      } else {
        sh <- as.numeric(sub("shift=", "", pk))
        subset(df_n, sz_orig != 0 & shift_size == sh)
      }

      panel_title <- if (pk == "pooled_sz0") {
        paste0("reg = ", reg_lab, " | n = ", n_val, " | sz=0 pooled (data-driven)")
      } else {
        paste0("reg = ", reg_lab, " | n = ", n_val, " | ", pk)
      }

      plot(NULL,
           xlim = range(bin_breaks), ylim = c(0, max_y),
           xlab = "Phenotype Value", ylab = "Proportion",
           main = panel_title)

      present_betas <- intersect(beta_all, sort(unique(df_panel$beta)))
      for (beta_val in present_betas) {
        avg_counts <- avg_curve_for_subset_pheno(subset(df_panel, beta == beta_val), bin_breaks, bin_mids)
        if (all(is.na(avg_counts))) next
        lines(bin_mids, avg_counts, col = beta_cols[as.character(beta_val)], lwd = 2)
      }

      # Gaussian overlay
      curve(dnorm(x, mean = 0, sd = sqrt(2000)),
              add = TRUE, col = "black", lty = 2, lwd = 2)

      legend("topright",
             legend = paste0("beta=", present_betas),
             col = beta_cols[as.character(present_betas)],
             lty = 1, lwd = 2, cex = 0.8, bg = "white")
    }

    par(op)
    dev.off()
  }
}

```

# PLOT PHENOTYPE OVER TIME
```{r}
# Helpers
.ph_compute_center <- function(df_block) {
  xcols <- grep("^X", names(df_block))
  if (!length(xcols) || nrow(df_block) == 0) return(NA_real_)
  vals <- suppressWarnings(as.numeric(unlist(df_block[, xcols])))
  vals <- vals[is.finite(vals)]
  if (!length(vals)) return(NA_real_)
  mean(vals)
}

.ph_avg_hist_with_breaks <- function(df_block, breaks, num_bins) {
  if (nrow(df_block) == 0) return(rep(NA_real_, num_bins))
  xcols <- grep("^X", names(df_block))
  reps  <- sort(unique(df_block$rep))
  if (!length(xcols) || !length(reps)) return(rep(NA_real_, num_bins))
  counts_mat <- matrix(NA_real_, nrow = length(reps), ncol = num_bins)
  for (i in seq_along(reps)) {
    row_i <- subset(df_block, rep == reps[i])[1, ]
    vals <- suppressWarnings(as.numeric(as.vector(unlist(row_i[, xcols]))))
    vals <- vals[is.finite(vals)]
    if (!length(vals)) next
    h <- hist(vals, breaks = breaks, plot = FALSE)
    if (sum(h$counts) == 0) next
    counts_mat[i, ] <- h$counts / sum(h$counts)
  }
  colMeans(counts_mat, na.rm = TRUE)
}

plot_phenotype_multi_by_beta <- function(phenotype_df,
                                        out_subfolder = "phenotype_multi_by_beta_genbins",
                                        gen_seq = 10000:10005,
                                        num_bins = num_bins,
                                        bin_width = bin_width,
                                        half_span = half_span,
                                        regimes = regimes) {

gen_cols <- hcl.colors(length(gen_seq), palette = "Berlin")
names(gen_cols) <- as.character(gen_seq)
  if (!("sz_orig" %in% names(phenotype_df))) {
    stop("phenotype_df must include sz_orig (original sz) to pool data-driven shift runs.")
  }
  if (!("reg" %in% names(phenotype_df))) {
    stop("phenotype_df must include 'reg' (e.g., 'ave' or 'fit').")
  }

  # Loop over regimes
  for (reg_lab in regimes) {
    df_reg <- subset(phenotype_df, reg == reg_lab)
    if (nrow(df_reg) == 0) next

    # Per-regime output dir
    out_dir <- file.path(base_plot_folder, out_subfolder, paste0("reg_", reg_lab))
    if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

    for (n_val in sort(unique(df_reg$n))) {
      df_n <- subset(df_reg, n == n_val)
      if (nrow(df_n) == 0) next

      has_sz0 <- any(df_n$sz_orig == 0, na.rm = TRUE)
      nonzero_shifts <- sort(unique(df_n$shift_size[df_n$sz_orig != 0]))
      shift_keys <- c(if (has_sz0) "pooled_sz0" else character(0),
                      if (length(nonzero_shifts)) paste0("shift=", nonzero_shifts) else character(0))

      all_betas <- sort(unique(df_n$beta))

      for (sk in shift_keys) {
        df_group <- if (sk == "pooled_sz0") {
          subset(df_n, sz_orig == 0)
        } else {
          sh <- as.numeric(sub("shift=", "", sk))
          subset(df_n, sz_orig != 0 & shift_size == sh)
        }
        if (nrow(df_group) == 0) next

        # Pass 1: common y-limit and x-range across all beta & gens
        max_y <- 0
        x_min <- Inf; x_max <- -Inf
        for (beta_val in all_betas) {
          df_p <- subset(df_group, beta == beta_val)
          if (nrow(df_p) == 0) next
          present_gens <- intersect(gen_seq, sort(unique(df_p$generation)))
          for (g in present_gens) {
            df_pg <- subset(df_p, generation == g)
            center <- .ph_compute_center(df_pg)
            if (!is.finite(center)) next
            breaks_g <- seq(center - half_span, center + half_span, by = bin_width)
            avg_counts <- .ph_avg_hist_with_breaks(df_pg, breaks_g, num_bins)
            max_y <- max(max_y, avg_counts, na.rm = TRUE)
            x_min <- min(x_min, min(breaks_g), na.rm = TRUE)
            x_max <- max(x_max, max(breaks_g), na.rm = TRUE)
          }
        }
        if (!is.finite(max_y) || max_y <= 0) max_y <- 1
        if (!is.finite(x_min) || !is.finite(x_max) || x_min >= x_max) {
          x_min <- -half_span; x_max <- half_span
        }

        # Layout
        K <- length(all_betas)
        ncol <- ceiling(sqrt(K))
        nrow <- ceiling(K / ncol)
        png_w <- 900 * ncol
        png_h <- 700 * nrow

        title_suffix <- if (sk == "pooled_sz0") {
          "pooled sz=0 (per-beta avg shift shown in panels)"
        } else {
          sh <- as.numeric(sub("shift=", "", sk))
          paste0("shift_size = ", sh)
        }

        out_name <- paste0("phenotype_multi_by_beta_reg_", reg_lab,
                           "_n_", n_val, "_", gsub("[ =]", "", title_suffix), ".png")
        png(file.path(out_dir, out_name), width = png_w, height = png_h)
        op <- par(mfrow = c(nrow, ncol), mar = c(4, 4, 3, 1) + 0.1, oma = c(0, 0, 3.5, 0))

        for (beta_val in all_betas) {
          df_p <- subset(df_group, beta == beta_val)

          # Panel title: if pooled sz=0, show per-beta mean shift_size
          panel_title <- if (sk == "pooled_sz0") {
            mbeta <- mean(df_p$shift_size, na.rm = TRUE)
            if (!is.finite(mbeta)) mbeta <- NA_real_
            paste0("beta = ", beta_val, " | avg shift_size = ",
                   if (is.na(mbeta)) "NA" else formatC(mbeta, format = "f", digits = 3))
          } else {
            paste0("beta = ", beta_val)
          }

          plot(NULL,
               xlim = c(x_min, x_max), ylim = c(0, max_y),
               xlab = "Phenotype Value", ylab = "Proportion",
               main = panel_title)

          present_gens <- intersect(gen_seq, sort(unique(df_p$generation)))
          for (g in present_gens) {
            df_pg <- subset(df_p, generation == g)
            center <- .ph_compute_center(df_pg)
            if (!is.finite(center)) next
            breaks_g <- seq(center - half_span, center + half_span, by = bin_width)
            mids_g   <- 0.5 * (breaks_g[-length(breaks_g)] + breaks_g[-1])
            avg_counts <- .ph_avg_hist_with_breaks(df_pg, breaks_g, num_bins)
            if (all(is.na(avg_counts))) next
            lines(mids_g, avg_counts, col = gen_cols[as.character(g)], lwd = 2)
          }
          curve(dnorm(x, mean = sh, sd = sqrt(2000)),
              add = TRUE, col = "black", lty = 2, lwd = 2)

          legend("topright",
                 legend = paste0("gen ", present_gens),
                 col = gen_cols[as.character(present_gens)],
                 lty = 1, lwd = 2, cex = 0.8, bg = "white")
        }

        mtext(paste0("Phenotype distributions (gen-specific bins) | reg = ", reg_lab,
                     " | n = ", n_val, " | ", title_suffix),
              outer = TRUE, cex = 1.1, line = 1.2)

        par(op)
        dev.off()
      }
    }
  }
}

num_bins <- 100
bin_breaks <- seq(-50, 50, length.out = num_bins + 1)

# Derive constant bin width from your current breaks
bin_width <- (max(bin_breaks) - min(bin_breaks)) / num_bins
half_span <- (num_bins * bin_width) / 2

# ---- Run ----
plot_phenotype_multi_by_beta(
  phenotype_df,
  # out_subfolder = "phenotype_overtime_10000:10005",
  # gen_seq = seq(10000, 10005, by = 1),
  # out_subfolder = "phenotype_overtime_10000:10010",
  # gen_seq = seq(10000, 10010, by = 2),
  # out_subfolder = "phenotype_overtime_10010:10100",
  # gen_seq = seq(10010, 10100, by = 5),
  out_subfolder = "phenotype_overtime_10000:10100",
  gen_seq = seq(10000, 10100, by = 10),
  num_bins = num_bins,
  bin_width = bin_width,
  half_span = half_span,
  regimes = c("inv")   # e.g., c("ave","fit")
)


```

# load SUMMARY STATS data
```{r}
# Top-level folder
folder <- file.path(base_data_folder, "data")

# List all .tsv files recursively
file_list <- list.files(
  path = folder,
  pattern = "\\.tsv$",
  full.names = TRUE,
  recursive = TRUE
)

# Extract metadata from filename:
#   data/n_<n>/beta_<beta>/sz_<shift_size>/_reg_<inv|var>_<rep>.tsv
extract_sum_metadata <- function(path) {
  rx <- "data/n_(\\d+)_beta_(-?[0-9.]+)_sz_(\\d+)_reg_(inv|var)_(\\d+)\\.tsv"
  m  <- regexec(rx, path)
  p  <- regmatches(path, m)[[1]]

  if (length(p) != 6) {
    warning("Could not extract metadata from path: ", path)
    return(data.frame())
  }

  data.frame(
    n          = as.integer(p[2]),
    beta        = as.numeric(p[3]),
    shift_size = as.integer(p[4]),
    reg        = p[5],                 # "ave" or "fit"
    rep        = as.integer(p[6]),
    file_id    = basename(path),
    stringsAsFactors = FALSE
  )
}

# Read and combine all files
summary_stat_df <- do.call(rbind, lapply(file_list, function(file) {
  df <- tryCatch(read.table(file, header = TRUE, sep = "\t", check.names = FALSE),
                 error = function(e) NULL)
  if (is.null(df)) {
    warning("Failed to read: ", file)
    return(NULL)
  }

  meta <- extract_sum_metadata(file)
  if (nrow(meta) == 0) return(NULL)
  if (meta$shift_size == 0) {
    return(NULL)
  }

  # Attach metadata columns
  df$n          <- meta$n
  df$beta        <- meta$beta
  df$shift_size <- meta$shift_size
  df$reg        <- meta$reg
  df$rep        <- meta$rep
  df$file_id    <- meta$file_id

  df
}))

```

## plot SUMMARY STATS (seg_site over time)
```{r}
# ---------------------------------------------------------
# seg_site vs tick (9999–10005), organized by regime folders
# One PDF per value of `split_var` (default: beta)
# Each PDF contains multiple panels (one panel per n)
# Inside each panel: x = tick 9999..10005, y = seg_site
# ---------------------------------------------------------

tick_window <- 9999:10010
rep_col  <- adjustcolor("gray30", alpha.f = 0.35)
mean_col <- "black"

# ---- Choose how to split plots ----
# If you literally want "one plot per distinct dist_norm", set:
# split_var <- "dist_norm"
split_var <- "beta"

# ---- Helper: compute per-rep series and across-rep mean for seg_site ----
.compute_seg_series <- function(df, ticks) {
  needed <- c("tick","rep","seg_site")
  if (!all(needed %in% names(df))) {
    return(list(reps = list(), mean = rep(NA_real_, length(ticks))))
  }
  d <- df
  d$tick     <- suppressWarnings(as.integer(d$tick))
  d$rep      <- suppressWarnings(as.integer(d$rep))
  d$seg_site <- suppressWarnings(as.numeric(d$seg_site))
  d <- d[is.finite(d$tick) & is.finite(d$rep) & is.finite(d$seg_site) & d$tick %in% ticks, , drop = FALSE]
  if (!nrow(d)) return(list(reps = list(), mean = rep(NA_real_, length(ticks))))

  # average within (tick, rep) to be safe
  agg <- aggregate(seg_site ~ tick + rep, data = d, FUN = function(v) mean(v, na.rm = TRUE))
  reps <- sort(unique(agg$rep))

  rep_series <- lapply(reps, function(r) {
    yv <- rep(NA_real_, length(ticks))
    rows <- agg[agg$rep == r, , drop = FALSE]
    if (nrow(rows)) {
      idx <- match(rows$tick, ticks)
      yv[idx] <- rows$seg_site
    }
    yv
  })
  names(rep_series) <- as.character(reps)

  if (length(rep_series)) {
    mat <- do.call(rbind, rep_series)
    mean_series <- apply(mat, 2L, function(col) mean(col, na.rm = TRUE))
  } else {
    mean_series <- rep(NA_real_, length(ticks))
  }

  list(reps = rep_series, mean = mean_series)
}

# ---- Main plotting function ----
plot_seg_site_by_tick <- function(df,
                                  out_root = "seg_site_by_tick_panels",
                                  regimes = NULL) {
  # Ensure regime column exists
  if (!"reg" %in% names(df)) df$reg <- "all"

  # Determine regimes
  if (is.null(regimes)) regimes <- sort(unique(df$reg))

  # Create root output folder
  if (!dir.exists(file.path(base_plot_folder, out_root))) {
    dir.create(file.path(base_plot_folder, out_root), recursive = TRUE)
  }

  # Basic coercions we'll reuse
  df$tick <- suppressWarnings(as.integer(df$tick))
  df$n    <- suppressWarnings(as.integer(df$n))

  for (reg_lab in regimes) {
    df_reg <- subset(df, reg == reg_lab & tick %in% tick_window)
    if (!nrow(df_reg)) next

    # Make regime-specific folder
    out_dir <- file.path(base_plot_folder, out_root, paste0("reg_", reg_lab))
    if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

    # Unique split values (e.g., beta or dist_norm)
    if (!split_var %in% names(df_reg)) {
      warning("split_var '", split_var, "' not found; skipping reg=", reg_lab)
      next
    }
    split_vals <- sort(unique(df_reg[[split_var]]))

    # Panels are by n
    n_vals <- sort(unique(df_reg$n))
    if (!length(n_vals)) next

    # Layout sizing
    ncol <- ceiling(sqrt(length(n_vals)))
    nrow <- ceiling(length(n_vals) / ncol)
    pdf_w <- 9 * ncol  # inches
    pdf_h <- 7 * nrow  # inches

    for (sv in split_vals) {
      df_sv <- subset(df_reg, df_reg[[split_var]] == sv)
      if (!nrow(df_sv)) next

      # Build a nice filename-safe label
      sv_lab <- if (is.numeric(sv)) formatC(as.numeric(sv), format = "f", digits = 3) else as.character(sv)
      sv_tag <- gsub("[^A-Za-z0-9._-]+", "_", sv_lab)

      out_file <- file.path(out_dir,
                            paste0("seg_site_vs_tick_by_n_",
                                   split_var, "_", sv_tag, ".pdf"))
      pdf(out_file, width = pdf_w, height = pdf_h)
      op <- par(mfrow = c(nrow, ncol), mar = c(4,4,3,1) + 0.1, oma = c(0,0,3,0))

      # Determine y-range across all panels to keep consistent
      y_min <- Inf; y_max <- -Inf
      panel_series <- vector("list", length(n_vals))
      names(panel_series) <- as.character(n_vals)

      for (i in seq_along(n_vals)) {
        nv <- n_vals[i]
        dfn <- subset(df_sv, n == nv)
        s <- .compute_seg_series(dfn, tick_window)
        panel_series[[i]] <- s
        y_all <- c(unlist(s$reps, use.names = FALSE), s$mean)
        y_all <- y_all[is.finite(y_all)]
        if (length(y_all)) {
          y_min <- min(y_min, y_all)
          y_max <- max(y_max, y_all)
        }
      }
      if (!is.finite(y_min) || !is.finite(y_max) || y_min == y_max) {
        y_min <- 0; y_max <- 1
      }

      # Draw panels
      for (i in seq_along(n_vals)) {
        nv <- n_vals[i]
        s  <- panel_series[[i]]
        main_lab <- paste0("n = ", nv)

        plot(NA, xlim = range(tick_window), ylim = c(y_min, y_max),
             xlab = "Tick", ylab = "seg_site", main = main_lab, xaxt = "n")
        axis(1, at = tick_window)

        if (length(s$reps)) {
          for (r in seq_along(s$reps)) {
            lines(tick_window, s$reps[[r]], col = rep_col, lwd = 1)
            points(tick_window, s$reps[[r]], pch = 16, cex = 0.5, col = rep_col)
          }
        }
        lines(tick_window, s$mean, col = mean_col, lwd = 2)
        points(tick_window, s$mean, pch = 16, cex = 0.9, col = mean_col)

        legend("topleft", inset = 0.02,
               legend = c("Replicate", "Across-rep mean"),
               col = c(rep_col, mean_col), lty = 1, lwd = c(1,2),
               pch = c(16,16), pt.cex = c(0.5,0.9), bty = "n", cex = 0.85)
      }

      # Top title per PDF
      mtext(paste0("seg_site vs tick (", min(tick_window), " to ", max(tick_window), ")",
                   " | reg = ", reg_lab,
                   " | one plot per ", split_var, " = ", sv_lab),
            outer = TRUE, cex = 1.05, line = 1.0)

      par(op)
      dev.off()
    }
  }
}

# ---- Run ----
# Will create base_plot_folder/seg_site_by_tick_panels/reg_ave and reg_fit, etc.
plot_seg_site_by_tick(summary_stat_df,
                      out_root = "seg_site_by_tick_panels",
                      regimes = c("inv","var"))

```

## plot dist_norm helper
```{r}
# --------------------------------------------
# Summary stats multipanel with exp-decay fits
# Plots dist_norm vs ticks, per beta
# Special case: at tick 9999, use |z_mean - opt(rep, tick=10000)| for plotting only
# (tick 9999 is EXCLUDED from the exponential fit)
# --------------------------------------------

tick_seq <- 9999:10100
rep_col  <- adjustcolor("gray30", alpha.f = 0.35)
mean_col <- "black"

.per_beta_avg_shift <- function(df_panel) {
  if ("optimum" %in% names(df_panel)) {
    v <- df_panel$optimum[df_panel$tick == 10001]
    v <- v[is.finite(v)]
    if (length(v)) return(mean(v))
  }
  v <- df_panel$shift_size
  v <- v[is.finite(v)]
  if (!length(v)) return(NA_real_)
  mean(v)
}

.compute_series <- function(df_panel, tick_seq) {
  # Need z_mean and (ideally) optimum for dynamic replacement at tick 9999
  needed <- c("dist_norm","tick","rep","z_mean")
  if (!all(needed %in% names(df_panel))) {
    return(list(reps = list(), mean = rep(NA_real_, length(tick_seq)), present_ticks = integer(0)))
  }

  df_sub <- df_panel

  # Coerce
  dist_norm_num <- suppressWarnings(as.numeric(df_sub$dist_norm))
  z_mean_num    <- suppressWarnings(as.numeric(df_sub$z_mean))
  df_sub$tick   <- suppressWarnings(as.integer(df_sub$tick))
  df_sub$rep    <- suppressWarnings(as.integer(df_sub$rep))

  # Base y from dist_norm
  y <- dist_norm_num

  # ----- Dynamic special-case at tick 9999: y <- |z_mean - opt_rep_at_10000| -----
  # Use per-rep optimum at tick 10000 if available; otherwise skip replacement for that rep
  if ("optimum" %in% names(df_sub)) {
    opt_num <- suppressWarnings(as.numeric(df_sub$optimum))
    # collect per-rep optimum at tick 10000
    rows_opt <- is.finite(opt_num) & is.finite(df_sub$rep) & (df_sub$tick == 10000)
    if (any(rows_opt)) {
      opt_tab <- tapply(opt_num[rows_opt], df_sub$rep[rows_opt], function(v) mean(v, na.rm = TRUE))
      # map per-row rep -> optimum
      rep_ids   <- as.integer(names(opt_tab))
      match_idx <- match(df_sub$rep, rep_ids)
      rep_opt   <- rep(NA_real_, nrow(df_sub))
      good_m    <- !is.na(match_idx)
      rep_opt[good_m] <- as.numeric(opt_tab)[match_idx[good_m]]

      # apply at tick 9999 where we have z_mean and rep_opt
      idx_9999 <- (df_sub$tick == 9999) & is.finite(z_mean_num) & is.finite(rep_opt)
      y[idx_9999] <- rep_opt[idx_9999] - z_mean_num[idx_9999]
    }
  }

  df_sub$y <- y

  # Keep finite rows
  df_sub <- df_sub[is.finite(df_sub$y) & is.finite(df_sub$tick) & is.finite(df_sub$rep), , drop = FALSE]
  if (!nrow(df_sub)) return(list(reps = list(), mean = rep(NA_real_, length(tick_seq)), present_ticks = integer(0)))

  # Aggregate by tick,rep
  agg <- aggregate(y ~ tick + rep, data = df_sub, FUN = mean)
  reps <- sort(unique(agg$rep))

  rep_series <- lapply(reps, function(r) {
    yv <- rep(NA_real_, length(tick_seq))
    rows <- agg[agg$rep == r & agg$tick %in% tick_seq, , drop = FALSE]
    if (nrow(rows)) {
      idx <- match(rows$tick, tick_seq)
      yv[idx] <- rows$y
    }
    yv
  })
  names(rep_series) <- as.character(reps)

  if (length(rep_series)) {
    mat <- do.call(rbind, rep_series)
    mean_series  <- apply(mat, 2L, function(col) mean(col, na.rm = TRUE))
    present_ticks <- tick_seq[colSums(!is.na(mat)) > 0]
  } else {
    mean_series <- rep(NA_real_, length(tick_seq))
    present_ticks <- integer(0)
  }

  list(reps = rep_series, mean = mean_series, present_ticks = present_ticks)
}

# ---------- Exponential-decay fit helpers ----------
# Model: y(x) = c0 + c1 * exp( -k * (x - t0) ), with t0 = min(x) fixed
.fit_exp_decay <- function(x, y) {
  x <- as.numeric(x); y <- as.numeric(y)
  ok <- is.finite(x) & is.finite(y)
  x <- x[ok]; y <- y[ok]
  if (length(x) < 5) {
    return(list(success = FALSE, params = NA, x_fit = x, y_fit = rep(NA_real_, length(x)), r2 = NA_real_))
  }
  ord <- order(x); x <- x[ord]; y <- y[ord]
  t0 <- min(x)

  tail_n <- max(5L, ceiling(0.2 * length(y)))
  c0_guess <- median(tail(y, tail_n), na.rm = TRUE)
  c1_guess <- max(1e-8, y[1] - c0_guess)
  k_guess  <- 0.01

  y_shift <- pmax(y - c0_guess, 1e-8)
  lm_fit <- try(suppressWarnings(lm(log(y_shift) ~ I(x - t0))), silent = TRUE)
  if (!inherits(lm_fit, "try-error")) {
    k_guess  <- max(1e-6, -coef(lm_fit)[2])
    c1_guess <- max(1e-8, exp(coef(lm_fit)[1]))
  }

  df <- data.frame(x = x, y = y)
  nls_fit <- try(
    suppressWarnings(
      nls(y ~ c0 + c1 * exp(-k * (x - t0)),
          data = df,
          start = list(c0 = c0_guess, c1 = c1_guess, k = k_guess),
          control = list(maxiter = 200, warnOnly = TRUE))
    ),
    silent = TRUE
  )

  if (inherits(nls_fit, "try-error")) {
    if (is.finite(k_guess) && is.finite(c1_guess) && is.finite(c0_guess)) {
      c0 <- c0_guess; c1 <- c1_guess; k <- k_guess
      y_hat <- c0 + c1 * exp(-k * (x - t0))
      sse <- sum((y - y_hat)^2, na.rm = TRUE)
      sst <- sum((y - mean(y, na.rm = TRUE))^2, na.rm = TRUE)
      r2  <- if (sst > 0) 1 - sse/sst else NA_real_
      return(list(success = TRUE, params = c(c0 = c0, c1 = c1, k = k, t0 = t0),
                  x_fit = x, y_fit = y_hat, r2 = r2))
    } else {
      return(list(success = FALSE, params = NA, x_fit = x, y_fit = rep(NA_real_, length(x)), r2 = NA_real_))
    }
  }

  co <- coef(nls_fit)
  c0 <- unname(co["c0"]); c1 <- unname(co["c1"]); k <- unname(co["k"])
  y_hat <- c0 + c1 * exp(-k * (x - t0))
  sse <- sum((y - y_hat)^2, na.rm = TRUE)
  sst <- sum((y - mean(y, na.rm = TRUE))^2, na.rm = TRUE)
  r2  <- if (sst > 0) 1 - sse/sst else NA_real_

  list(success = TRUE, params = c(c0 = c0, c1 = c1, k = k, t0 = t0),
       x_fit = x, y_fit = y_hat, r2 = r2)
}

.fmt <- function(x, d = 3) formatC(x, format = "f", digits = d)

# ---------- Main plotting function ----------
plot_summary_multi_by_beta_ticks <- function(summary_stat_df,
                                            out_subfolder = "summary_multi_by_beta_ticks",
                                            regimes = NULL) {
  if (!dir.exists(file.path(base_plot_folder, out_subfolder))) {
    dir.create(file.path(base_plot_folder, out_subfolder), recursive = TRUE)
  }

  if (is.null(regimes)) {
    if ("reg" %in% names(summary_stat_df)) {
      regimes <- sort(unique(summary_stat_df$reg))
    } else {
      regimes <- "all"
      summary_stat_df$reg <- "all"
    }
  }

  has_sz_orig <- "sz_orig" %in% names(summary_stat_df)

  for (reg_lab in regimes) {
    df_reg <- subset(summary_stat_df, reg == reg_lab)
    if (nrow(df_reg) == 0) next

    out_dir <- file.path(base_plot_folder, out_subfolder, paste0("reg_", reg_lab))
    if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

    for (n_val in sort(unique(df_reg$n))) {
      df_n <- subset(df_reg, n == n_val)
      if (nrow(df_n) == 0) next

      if (has_sz_orig) {
        has_sz0 <- any(df_n$sz_orig == 0, na.rm = TRUE)
        nonzero <- sort(unique(df_n$shift_size[df_n$sz_orig != 0]))
        shift_keys <- c(if (has_sz0) "pooled_sz0" else character(0),
                        if (length(nonzero)) paste0("shift=", nonzero) else character(0))
      } else {
        has_sz0 <- any(df_n$shift_size == 0, na.rm = TRUE)
        nonzero <- sort(unique(df_n$shift_size[df_n$shift_size != 0]))
        shift_keys <- c(if (has_sz0) "pooled_sz0" else character(0),
                        if (length(nonzero)) paste0("shift=", nonzero) else character(0))
      }

      all_betas <- sort(unique(df_n$beta))

      for (sk in shift_keys) {
        df_group <- if (sk == "pooled_sz0") {
          if (has_sz_orig) subset(df_n, sz_orig == 0) else subset(df_n, shift_size == 0)
        } else {
          sh <- as.numeric(sub("shift=", "", sk))
          if (has_sz_orig) subset(df_n, ifelse(is.na(sz_orig), FALSE, sz_orig != 0) & shift_size == sh)
          else subset(df_n, shift_size == sh)
        }
        if (nrow(df_group) == 0) next

        # Y-limits across panels
        y_min <- Inf; y_max <- -Inf
        for (beta_val in all_betas) {
          df_p <- subset(df_group, beta == beta_val & tick %in% tick_seq)
          s <- .compute_series(df_p, tick_seq)
          y_all <- c(unlist(s$reps, use.names = FALSE), s$mean)
          y_all <- y_all[is.finite(y_all)]
          if (length(y_all)) {
            y_min <- min(y_min, y_all)
            y_max <- max(y_max, y_all)
          }
        }
        if (!is.finite(y_min) || !is.finite(y_max) || y_min == y_max) {
          y_min <- 0; y_max <- 1
        }

        K <- length(all_betas)
        ncol <- ceiling(sqrt(K))
        nrow <- ceiling(K / ncol)
        pdf_w <- 9 * ncol   # inches
        pdf_h <- 7 * nrow   # inches

        title_suffix <- if (sk == "pooled_sz0") {
          "pooled sz=0 (per-beta avg shift shown in panels)"
        } else {
          sh <- as.numeric(sub("shift=", "", sk))
          paste0("shift_size = ", sh)
        }

        out_name <- paste0("summary_multi_by_beta_ticks_reg_", reg_lab,
                           "_n_", n_val, "_", gsub("[ =]", "", title_suffix), ".pdf")

        pdf(file.path(out_dir, out_name), width = pdf_w, height = pdf_h)
        op <- par(mfrow = c(nrow, ncol), mar = c(4, 4, 3, 1) + 0.1, oma = c(0, 0, 3.5, 0))

        for (beta_val in all_betas) {
          df_p <- subset(df_group, beta == beta_val & tick %in% tick_seq)

          panel_title <- if (sk == "pooled_sz0") {
            mbeta <- .per_beta_avg_shift(df_p)
            paste0("beta = ", beta_val, " | avg shift_size = ",
                   if (is.finite(mbeta)) formatC(mbeta, format = "f", digits = 3) else "NA")
          } else {
            paste0("beta = ", beta_val)
          }

          plot(NA, xlim = range(tick_seq), ylim = c(y_min, y_max),
               xlab = "Tick", ylab = "dist_norm", main = panel_title,
               xaxt = "n")
          axis(1, at = tick_seq)

          s <- .compute_series(df_p, tick_seq)

          # Replicate series
          if (length(s$reps)) {
            for (r in seq_along(s$reps)) {
              lines(tick_seq, s$reps[[r]], col = rep_col, lwd = 1)
              points(tick_seq, s$reps[[r]], pch = 16, cex = 0.5, col = rep_col)
            }
          }
          # Across-rep mean (already with dynamic 9999 substitution)
          lines(tick_seq, s$mean, col = mean_col, lwd = 2)
          points(tick_seq, s$mean, pch = 16, cex = 0.9, col = mean_col)

          # ---- Exponential-decay fit (exclude tick 9999 from fitting) ----
          if (is.finite(min(s$mean, na.rm = TRUE)) && is.finite(max(s$mean, na.rm = TRUE))) {
            present <- is.finite(s$mean) & (tick_seq != 9999)
            x_fit <- tick_seq[present]
            y_fit <- s$mean[present]
            if (length(x_fit) >= 5 && diff(range(y_fit)) > 0) {
              fit <- .fit_exp_decay(x_fit, y_fit)
              if (isTRUE(fit$success)) {
                lines(fit$x_fit, fit$y_fit, col = "red", lwd = 2, lty = 2)

                k <- fit$params["k"]
                tau <- if (is.finite(k) && k > 0) 1/k else NA_real_
                t_half <- if (is.finite(k) && k > 0) log(2)/k else NA_real_

                legend("topright", inset = 0.02,
                       legend = c(
                         "Exp fit: y = c0 + c1*e^{-k(x - t0)}",
                         paste0("c0=", .fmt(fit$params["c0"]), ", c1=", .fmt(fit$params["c1"])),
                         paste0("k=", .fmt(k), "  (tau= ", .fmt(tau), ", t1/2= ", .fmt(t_half), ")"),
                         paste0("R^2=", .fmt(fit$r2)),
                         "Note: tick 9999 excluded from fit"
                       ),
                       col = c(NA, "red", "red", "red", NA),
                       lty = c(NA, 2, 2, 2, NA), lwd = c(NA, 2, 2, 2, NA),
                       bty = "n", cex = 0.78, text.col = c("black","red","red","red","black"))
              }
            }
          }

          legend("bottomleft", inset = 0.02,
                 legend = c("Replicate", "Across-rep mean", "Exp. decay fit"),
                 col    = c(rep_col, mean_col, "red"),
                 lty    = c(1,       1,        2),
                 lwd    = c(1,       2,        2),
                 pch    = c(16,      16,       NA),
                 pt.cex = c(0.5,     0.9,      NA),
                 bty = "n", cex = 0.85)
        }

        mtext(paste0("Summary: dist_norm over ticks (9999 uses |z_mean - opt@10000|) | reg = ",
                     reg_lab, " | n = ", n_val, " | ", title_suffix),
              outer = TRUE, cex = 1.05, line = 1.2)

        par(op)
        dev.off()
      }
    }
  }
}

```

```{r}

# ---- Run ----
plot_summary_multi_by_beta_ticks(summary_stat_df,
                                out_subfolder = "distanct_from_opt_overtime",
                                regimes = regimes)

```

## EXPONENTIAL-DECAY FITTING helper
```{r}
# --------- 1) Collect decay metrics per (reg, shift_key, n, beta) ----------
# Choose which speed metric to compare:
.metric <- function(k) {
  if (is.finite(k) && k > 0) return(log(2)/k)  # half-life
  NA_real_
}

# Optional: try to pull a SE for k from nls for CIs (falls back to NA)
.fit_exp_decay_with_se <- function(x, y) {
  base <- .fit_exp_decay(x, y)
  if (!isTRUE(base$success)) return(c(base, list(k_se = NA_real_)))
  # Try SE
  k_se <- NA_real_
  df <- data.frame(x = base$x_fit, y = y[match(base$x_fit, x)])
  t0 <- min(base$x_fit)
  nls_try <- try(
    suppressWarnings(
      nls(y ~ c0 + c1 * exp(-k * (x - t0)),
          data = df,
          start = list(c0 = base$params["c0"], c1 = base$params["c1"], k = base$params["k"]),
          control = list(maxiter = 200, warnOnly = TRUE))
    ), silent = TRUE
  )
  if (!inherits(nls_try, "try-error")) {
    s <- try(summary(nls_try), silent = TRUE)
    if (!inherits(s, "try-error")) {
      if ("k" %in% rownames(s$parameters)) k_se <- s$parameters["k", "Std. Error"]
    }
  }
  c(base, list(k_se = k_se))
}

# Compute table
compute_decay_table <- function(df, tick_seq) {
  stopifnot(all(c("n","beta","tick","reg","shift_size") %in% names(df)))
  # (optional) handle sz_orig==0 pooling same as your plotting code
  has_sz_orig <- "sz_orig" %in% names(df)

  out <- list()

  for (reg_val in sort(unique(df$reg))) {
    df_reg <- subset(df, reg == reg_val)
    if (!nrow(df_reg)) next

    for (n_val in sort(unique(df_reg$n))) {
      df_n <- subset(df_reg, n == n_val)
      if (!nrow(df_n)) next

      # Build shift groups: pooled sz=0 vs each fixed shift
      if (has_sz_orig) {
        has_sz0 <- any(df_n$sz_orig == 0, na.rm = TRUE)
        nonzero <- sort(unique(df_n$shift_size[df_n$sz_orig != 0]))
        shift_keys <- c(if (has_sz0) "pooled_sz0" else character(0),
                        if (length(nonzero)) paste0("shift=", nonzero) else character(0))
      } else {
        has_sz0 <- any(df_n$shift_size == 0, na.rm = TRUE)
        nonzero <- sort(unique(df_n$shift_size[df_n$shift_size != 0]))
        shift_keys <- c(if (has_sz0) "pooled_sz0" else character(0),
                        if (length(nonzero)) paste0("shift=", nonzero) else character(0))
      }

      for (sk in shift_keys) {
        df_group <- if (sk == "pooled_sz0") {
          if (has_sz_orig) subset(df_n, sz_orig == 0) else subset(df_n, shift_size == 0)
        } else {
          sh <- as.numeric(sub("shift=", "", sk))
          if (has_sz_orig) subset(df_n, ifelse(is.na(sz_orig), FALSE, sz_orig != 0) & shift_size == sh)
          else subset(df_n, shift_size == sh)
        }
        if (!nrow(df_group)) next

        for (beta_val in sort(unique(df_group$beta))) {
          df_p <- subset(df_group, beta == beta_val & tick %in% tick_seq)
          s <- .compute_series(df_p, tick_seq)

          # Fit to across-rep mean, excluding tick 9999
          present <- is.finite(s$mean) & (tick_seq != 9999)
          x_fit <- tick_seq[present]
          y_fit <- s$mean[present]

          if (length(x_fit) >= 5 && diff(range(y_fit, na.rm = TRUE)) > 0) {
            fit <- .fit_exp_decay_with_se(x_fit, y_fit)
            if (isTRUE(fit$success)) {
              k  <- unname(fit$params["k"])
              se <- fit$k_se
              t12 <- .metric(k)
              out[[length(out)+1]] <- data.frame(
                reg = reg_val,
                shift_key = sk,
                n = n_val,
                beta = beta_val,
                k = k,
                k_se = se,
                t_half = t12,
                r2 = fit$r2,
                stringsAsFactors = FALSE
              )
            }
          }
        }
      }
    }
  }

  if (!length(out)) return(data.frame())
  do.call(rbind, out)
}

compute_jump <- function(df, tick_seq = 9999:10000, relative=TRUE) {
  s <- .compute_series(df, tick_seq)
  yvals <- s$mean
  if (length(yvals) < 2 || any(!is.finite(yvals))) return(NA_real_)
  # jump = y(9999) - y(10000)/opt
  if (!relative) return(yvals[1] - yvals[2])
  else return((yvals[1] - yvals[2])/df$optimum[df$tick == 10000][1])
}

compute_jump_table <- function(df, relative=TRUE) {
  out <- list()
  for (reg_val in sort(unique(df$reg))) {
    df_reg <- subset(df, reg == reg_val)
    for (n_val in sort(unique(df_reg$n))) {
      df_n <- subset(df_reg, n == n_val)
      for (sk in sort(unique(df_n$shift_size))) {
        if (sk == 0) next
        df_sk <- subset(df_n, shift_size == sk)
        for (beta_val in sort(unique(df_sk$beta))) {
          df_p <- subset(df_sk, beta == beta_val & tick %in% 9999:10000)
          if (!nrow(df_p)) next
          j <- compute_jump(df_p, relative=relative)
          out[[length(out)+1]] <- data.frame(
            reg = reg_val, n = n_val, shift_size = sk,
            beta = beta_val, jump = j
          )
        }
      }
    }
  }
  do.call(rbind, out)
}

```

### plot first gen jump (need func compute_series)
```{r}
jump_tbl <- compute_jump_table(summary_stat_df)

plot_jump_by_shift <- function(jump_tbl, out_subfolder = "dist_1st_gen") {
  out_dir <- file.path(base_plot_folder, out_subfolder)
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

  # pick distinct colors per reg
  regs <- sort(unique(jump_tbl$reg))
  reg_cols <- setNames(c("steelblue", "tomato", "darkgreen", "orange")[seq_along(regs)], regs)

  for (sk in sort(unique(jump_tbl$shift_size))) {
    df_sk <- subset(jump_tbl, shift_size == sk)
    if (!nrow(df_sk)) next

    ns <- sort(unique(df_sk$n))
    ncol <- ceiling(sqrt(length(ns)))
    nrow <- ceiling(length(ns)/ncol)

    pdf(file.path(out_dir, paste0("jump_", gsub("[ =]", "", sk), "_relative.pdf")),
        width = 9*ncol, height = 6*nrow)
    op <- par(mfrow = c(nrow,ncol), mar = c(5,5,3,1)+0.1, oma=c(0,0,3,0))

    for (n_val in ns) {
      df_n <- subset(df_sk, n == n_val)
      if (!nrow(df_n)) { plot.new(); next }

      # assign color by reg
      bar_cols <- reg_cols[as.character(df_n$reg)]

      barplot(height = df_n$jump,
              names.arg = paste0("beta=", df_n$beta, "\nreg=", df_n$reg),
              col = bar_cols,
              las = 2, main = paste0("n = ", n_val, " | shift=", sk),
              ylab = "first gen phenotype jump (% to opt)", cex.names = 0.7)
    }

    # global title + legend
    mtext(paste0("Jump from tick 9999-10000 | shift=", sk),
          outer=TRUE, cex=1.1, line=1)
    legend("topright", legend = names(reg_cols), fill = reg_cols, bty = "n")

    par(op); dev.off()
  }
}

plot_jump_by_shift(jump_tbl)

```

### plot decay variable (need compute_decay_table)
```{r}
# Plot fitted decay metric (k or half-life) vs beta, grouped by shift_key == "shift=..."
# Expects columns: reg, n, shift_key, beta, and either k or t_half
plot_decay_metric_by_shiftkey <- function(decay_tbl,
                                          metric = c("k","t_half")[1],
                                          out_subfolder = "decay_by_shiftkey",
                                          log_y = FALSE) {
  metric <- match.arg(metric)
  stopifnot(all(c("reg","n","shift_key","beta",metric) %in% names(decay_tbl)))

  # Keep finite metric rows
  df <- decay_tbl[is.finite(decay_tbl[[metric]]) & decay_tbl$k < 10, , drop = FALSE]
  if (!nrow(df)) { warning("No finite values for metric = ", metric); return(invisible(NULL)) }

  # Keep only keys like "shift=..." (skip pooled_sz0 etc.)
  keys <- as.character(df$shift_key)
  is_shift <- grepl("^shift=", keys)
  shift_size_num <- suppressWarnings(as.numeric(sub("^shift=", "", keys)))
  df <- df[is_shift & is.finite(shift_size_num), , drop = FALSE]
  if (!nrow(df)) { warning("No rows with shift_key of the form 'shift=...'"); return(invisible(NULL)) }
  df$shift_size <- shift_size_num[is_shift & is.finite(shift_size_num)]

  # Output folder
  out_dir <- file.path(base_plot_folder, out_subfolder)
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

  # Colors/markers for reg
  regs <- sort(unique(df$reg))
  reg_cols <- setNames(c("steelblue","tomato","darkgreen","orange","purple","gray40")[seq_along(regs)], regs)
  reg_pch  <- setNames(19 + seq_along(regs) - 1L, regs)  # 19,20,...

  ylab <- if (metric == "k") "Decay rate k (1/ticks)" else "Half-life t1/2 (ticks)"

  for (sk in sort(unique(df$shift_size))) {
    df_sk <- df[df$shift_size == sk, , drop = FALSE]
    if (!nrow(df_sk)) next

    ns <- sort(unique(df_sk$n))
    K  <- length(ns)
    ncol <- ceiling(sqrt(K)); nrow <- ceiling(K / ncol)

    # Shared y-limits across panels (unless log scale)
    y_all <- df_sk[[metric]]
    if (!log_y) {
      ylim <- range(y_all[is.finite(y_all)], na.rm = TRUE)
      if (!all(is.finite(ylim))) ylim <- c(0, 1)
      if (diff(ylim) == 0) ylim <- ylim + c(-0.5, 0.5)
    }

    pdf(file.path(out_dir, paste0("decay_", metric, "_shift_", gsub("[^0-9.-]", "", as.character(sk)), ".pdf")),
        width = 9*ncol, height = 6*nrow)
    op <- par(mfrow = c(nrow, ncol), mar = c(5,5,3,1)+0.1, oma = c(0,0,3,0), family = "sans")

    for (n_val in ns) {
      dp <- df_sk[df_sk$n == n_val, , drop = FALSE]
      if (!nrow(dp)) { plot.new(); next }

      betas <- sort(unique(dp$beta))

      if (log_y) {
        yl <- range(dp[[metric]][is.finite(dp[[metric]])], na.rm = TRUE)
        min_pos <- suppressWarnings(min(dp[[metric]][dp[[metric]] > 0], na.rm = TRUE))
        if (!is.finite(min_pos)) { plot.new(); next }
        yl[1] <- max(yl[1], min_pos/2)
        plot(NA, xlim = range(betas), ylim = yl, log = "y",
             xlab = "beta", ylab = ylab,
             main = paste0("n = ", n_val, "  |  shift = ", sk))
      } else {
        plot(NA, xlim = range(betas), ylim = ylim,
             xlab = "beta", ylab = ylab,
             main = paste0("n = ", n_val, "  |  shift = ", sk))
      }

      # One line per reg across beta
      for (rg in regs) {
        dpr <- dp[dp$reg == rg, , drop = FALSE]
        if (!nrow(dpr)) next
        ord <- order(dpr$beta)
        x <- dpr$beta[ord]; y <- dpr[[metric]][ord]
        lines(x, y, lwd = 2, col = reg_cols[[rg]])
        points(x, y, pch = reg_pch[[rg]], col = reg_cols[[rg]], cex = 1.1)
      }

      abline(h = pretty(par("usr")[3:4]), col = "gray90", lty = 3)
      abline(v = pretty(par("usr")[1:2]), col = "gray95", lty = 3)
    }

    mtext(paste0("Fitted exponential decay (", metric, ") vs beta  |  shift = ", sk),
          outer = TRUE, cex = 1.1, line = 1)
    legend("topright", legend = names(reg_cols), col = reg_cols, pch = reg_pch,
           lwd = 2, bty = "n", inset = 0.02, title = "reg")

    par(op); dev.off()
  }

  invisible(NULL)
}
decay_tbl <- compute_decay_table(summary_stat_df, tick_seq)
plot_decay_metric_by_shiftkey(decay_tbl, metric = "k", out_subfolder = "decay_rate")

```

### plot decay variable as heatmap
```{r}
plot_decay_heatmap_per_shift <- function(decay_tbl,
                                         metric = "k",
                                         out_subfolder = "decay_heatmaps_per_shift",
                                         global_scale = TRUE,
                                         panel_w = 4.0,   # inches per panel (wider -> no margin error)
                                         panel_h = 3.3,   # inches per panel (taller -> no margin error)
                                         legend_w = 1.1   # inches for legend column
) {
  metric <- match.arg(metric)
  need <- c("reg","n","beta","shift_key", metric)
  stopifnot(all(need %in% names(decay_tbl)))

  # keep finite metric
  df <- decay_tbl[is.finite(decay_tbl[[metric]]) & decay_tbl$k < 10 & decay_tbl$n > 19, , drop = FALSE]
  if (!nrow(df)) { warning("No finite rows for metric."); return(invisible(NULL)) }

  # keep only shift=... keys
  df <- df[grepl("^shift=", df$shift_key), , drop = FALSE]
  if (!nrow(df)) { warning("No rows with shift_key like 'shift=...'."); return(invisible(NULL)) }
  df$shift_size <- suppressWarnings(as.numeric(sub("^shift=", "", df$shift_key)))
  df <- df[is.finite(df$shift_size), , drop = FALSE]
  if (!nrow(df)) { warning("No numeric shift sizes parsed from shift_key."); return(invisible(NULL)) }

  betas_all <- sort(unique(df$beta))
  ns_all   <- sort(unique(df$n))

  # global color limits (shared across all shifts if requested)
  if (isTRUE(global_scale)) {
    zlim <- range(df[[metric]], na.rm = TRUE)
    if (!all(is.finite(zlim)) || diff(zlim) == 0) zlim <- zlim + c(-0.5, 0.5)
  }

  
  ncols_pal <- 120
  cols <- grDevices::colorRampPalette(c("#ffffff","#fdae61","#d7191c"))(ncols_pal)
  # cols <- col_fun(ncols_pal)

  out_dir <- file.path(base_plot_folder, out_subfolder)
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

  # panel/filler/legend margins (smaller to avoid the error)
  panel_mar  <- c(3, 3, 2, 1) + 0.1
  filler_mar <- c(0, 0, 0, 0)
  legend_mar <- c(3, 1, 2, 3) + 0.1

  for (sh in sort(unique(df$shift_size))) {
    dp_shift <- df[df$shift_size == sh, , drop = FALSE]
    if (!nrow(dp_shift)) next

    regs <- sort(unique(dp_shift$reg))
    R <- length(regs)
    ncol <- ceiling(sqrt(R))
    nrow <- ceiling(R / ncol)

    # per-shift zlim if needed
    if (!isTRUE(global_scale)) {
      zlim <- range(dp_shift[[metric]], na.rm = TRUE)
      if (!all(is.finite(zlim)) || diff(zlim) == 0) zlim <- zlim + c(-0.5, 0.5)
    }

    # layout: reg panels + legend column
    lay <- cbind(matrix(1:(nrow*ncol), nrow = nrow, ncol = ncol, byrow = TRUE),
                 rep(nrow*ncol + 1L, nrow))
    total_w <- ncol * panel_w + legend_w
    total_h <- nrow * panel_h

    pdf_path <- file.path(out_dir, paste0("decay_", metric, "_shift_", gsub("[^0-9.-]", "", sh), ".pdf"))
    if (capabilities("cairo")) {
      grDevices::cairo_pdf(file = pdf_path, width = total_w, height = total_h, family = "sans")
    } else {
      grDevices::pdf(file = pdf_path, width = total_w, height = total_h, family = "sans", useDingbats = FALSE)
    }

    layout(lay, widths = c(rep(1, ncol), legend_w / panel_w))  # legend width scaled to panel units

    # ---- panels by reg ----
    for (idx in seq_len(nrow*ncol)) {
      if (idx <= R) {
        rg <- regs[idx]
        par(mar = panel_mar)
        dpr <- dp_shift[dp_shift$reg == rg, , drop = FALSE]

        # build beta × n matrix (mean if duplicates)
        M <- matrix(NA_real_, nrow = length(betas_all), ncol = length(ns_all),
                    dimnames = list(paste0("beta=", betas_all), paste0("n=", ns_all)))
        if (nrow(dpr)) {
          for (i in seq_along(betas_all)) {
            for (j in seq_along(ns_all)) {
              v <- dpr[dpr$beta == betas_all[i] & dpr$n == ns_all[j], metric, drop = TRUE]
              if (length(v)) M[i, j] <- mean(v, na.rm = TRUE)
            }
          }
        }

        image(x = seq_along(ns_all), y = seq_along(betas_all), z = t(M),
              xaxt = "n", yaxt = "n", xlab = "n", ylab = "beta",
              col = cols, zlim = zlim)
        axis(1, at = seq_along(ns_all), labels = ns_all)
        axis(2, at = seq_along(betas_all), labels = betas_all, las = 1)
        box()
        title(main = paste0("reg = ", rg))
      } else {
        # filler cell to complete the grid
        par(mar = filler_mar)
        plot.new()
      }
    }

    # ---- legend column ----
    par(mar = legend_mar)
    zseq <- seq(zlim[1], zlim[2], length.out = ncols_pal)
    image(x = 1, y = zseq, z = matrix(zseq, nrow = 1),
          xaxt = "n", yaxt = "n", xlab = "", ylab = "", col = cols)
    axis(4, at = pretty(zlim), labels = formatC(pretty(zlim), digits = 3), las = 1)
    mtext(if (metric == "k") "k (1/ticks)" else "t1/2 (ticks)", side = 4, line = 3)
    box()

    dev.off()
  }

  invisible(NULL)
}
decay_tbl <- compute_decay_table(summary_stat_df, tick_seq)
# decay_tbl <- decay_tbl[decay_tbl$reg != "ext",]
plot_decay_heatmap_per_shift(decay_tbl, metric = "k", out_subfolder = "decay_k_heatmaps_n50")
```

### plot first gen jump heatmap
```{r}
# One heatmap PDF per shift size; panels = reg; cells = jump (9999→10000)
plot_jump_heatmap <- function(jump_tbl,
                                        out_subfolder = "jump_heatmaps_per_shift",
                                        global_scale = TRUE,   # share color scale across all shifts
                                        center_zero  = FALSE,  # make zlim symmetric around 0 (nice if jumps can be +/-)
                                        panel_w = 4.2, panel_h = 3.4, legend_w = 1.2) {

  need <- c("reg","n","beta","shift_size","jump")
  stopifnot(all(need %in% names(jump_tbl)))

  df <- jump_tbl[is.finite(jump_tbl$jump) & is.finite(jump_tbl$shift_size), , drop = FALSE]
  if (!nrow(df)) { warning("No finite jump values to plot."); return(invisible(NULL)) }

  # Use common beta/n grids so panels align
  betas_all <- sort(unique(df$beta))
  ns_all   <- sort(unique(df$n))

  # Global color limits (optional)
  if (isTRUE(global_scale)) {
    zlim <- range(df$jump, na.rm = TRUE)
    if (isTRUE(center_zero)) {
      maxabs <- max(abs(zlim), na.rm = TRUE)
      zlim <- c(-maxabs, maxabs)
    } else if (!all(is.finite(zlim)) || diff(zlim) == 0) {
      zlim <- zlim + c(-0.5, 0.5)
    }
  }

  # Palette: grayscale by default; diverging if centered at zero
  ncols_pal <- 120
  cols <- grDevices::colorRampPalette(c("#ffffff","#fdae61","#d7191c"))(ncols_pal)
  

  out_dir <- file.path(base_plot_folder, out_subfolder)
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

  panel_mar  <- c(3, 3, 2, 1) + 0.1
  filler_mar <- c(0, 0, 0, 0)
  legend_mar <- c(3, 1, 2, 3) + 0.1

  for (sh in sort(unique(df$shift_size))) {
    dp_shift <- df[df$shift_size == sh, , drop = FALSE]
    if (!nrow(dp_shift)) next

    regs <- sort(unique(dp_shift$reg))
    R <- length(regs)
    ncol <- ceiling(sqrt(R)); nrow <- ceiling(R / ncol)

    # Per-shift color limits if not global
    if (!isTRUE(global_scale)) {
      zlim <- range(dp_shift$jump, na.rm = TRUE)
      if (isTRUE(center_zero)) {
        maxabs <- max(abs(zlim), na.rm = TRUE)
        zlim <- c(-maxabs, maxabs)
      } else if (!all(is.finite(zlim)) || diff(zlim) == 0) {
        zlim <- zlim + c(-0.5, 0.5)
      }
    }

    # Layout: reg panels + legend
    lay <- cbind(matrix(1:(nrow*ncol), nrow = nrow, ncol = ncol, byrow = TRUE),
                 rep(nrow*ncol + 1L, nrow))
    total_w <- ncol * panel_w + legend_w
    total_h <- nrow * panel_h + 0.5

    pdf_path <- file.path(out_dir, paste0("jump_heatmap_shift_", gsub("[^0-9.-]", "", sh), ".pdf"))
    if (capabilities("cairo")) {
      grDevices::cairo_pdf(file = pdf_path, width = total_w, height = total_h, family = "sans")
    } else {
      grDevices::pdf(file = pdf_path, width = total_w, height = total_h, family = "sans", useDingbats = FALSE)
    }

    layout(lay, widths = c(rep(1, ncol), legend_w / panel_w))

    # ---- panels by reg ----
    for (idx in seq_len(nrow*ncol)) {
      if (idx <= R) {
        rg <- regs[idx]
        par(mar = panel_mar)
        dpr <- dp_shift[dp_shift$reg == rg, , drop = FALSE]

        # Build beta × n matrix; average if duplicate rows exist
        M <- matrix(NA_real_, nrow = length(betas_all), ncol = length(ns_all),
                    dimnames = list(paste0("beta=", betas_all), paste0("n=", ns_all)))
        if (nrow(dpr)) {
          for (i in seq_along(betas_all)) {
            for (j in seq_along(ns_all)) {
              v <- dpr[dpr$beta == betas_all[i] & dpr$n == ns_all[j], "jump", drop = TRUE]
              if (length(v)) M[i, j] <- mean(v, na.rm = TRUE)
            }
          }
        }

        image(x = seq_along(ns_all), y = seq_along(betas_all), z = t(M),
              xaxt = "n", yaxt = "n", xlab = "n", ylab = "beta",
              col = cols, zlim = zlim)
        axis(1, at = seq_along(ns_all), labels = ns_all)
        axis(2, at = seq_along(betas_all), labels = betas_all, las = 1)
        box()
        title(main = paste0("reg = ", rg))
      } else {
        par(mar = filler_mar); plot.new()
      }
    }
        # ---- legend column (with numeric ticks) ----
    par(mar = legend_mar)
    zseq <- seq(zlim[1], zlim[2], length.out = ncols_pal)

    # draw vertical color bar
    image(x = 1, y = zseq, z = matrix(zseq, nrow = 1),
          xaxt = "n", yaxt = "n", xlab = "", ylab = "",
          col = cols, zlim = zlim)

    # pretty tick marks within zlim
    ticks <- pretty(zlim, n = 6)
    ticks <- ticks[ticks >= zlim[1] & ticks <= zlim[2]]

    # numeric labels on the right side of the bar
    axis(4, at = ticks, labels = formatC(ticks, format = "fg", digits = 3), las = 1)
    # label + optional title
    mtext("first_gen jump (9999-10000)", side = 4, line = 3)
    title(main = paste0("shift = ", sh))
    box()

    dev.off()
  }

  invisible(NULL)
}
jump_tbl <- compute_jump_table(summary_stat_df, relative = FALSE)
# jump_tbl <- jump_tbl[jump_tbl$reg %in% c("fit", "ave"),]  # optional filter
# Using your existing jump_tbl:
plot_jump_heatmap(jump_tbl,
                            out_subfolder = "jump_heatmaps_per_shift",
                            global_scale = TRUE,   # comparable colors across shifts
                            center_zero  = FALSE,   # diverging colors centered at 0
                            panel_w = 4.2, panel_h = 3.4, legend_w = 1.0)

```


## process ind data
```{r}
# -------------------------
# BASE R IND-EFFECTS LOADER (fixed)
# -------------------------

# ---- CONFIG ----
folder      <- file.path(base_data_folder, "ind")
gen_filter  <- "10005"   # encoded in filenames to keep
target_strs <- sprintf("beta_%s", formatC(target_beta, format = "f", digits = 1))  # e.g., beta_-0.3

# ---- HELPERS ----

# Filename: ind/n_{n}_beta_{beta}_sz_{shift}_reg_{inv|var}_{rep}_gen{gen_filter}.tsv
extract_effect_metadata <- function(path) {
  rx <- paste0("ind/n_(\\d+)_beta_(-?[0-9.]+)_sz_(\\d+)_reg_(inv|var)_(\\d+)_gen", gen_filter, "\\.tsv")
  m  <- regexec(rx, path)
  p  <- regmatches(path, m)[[1]]
  if (length(p) != 6) {
    warning("Could not extract metadata from path: ", path, " | parts: ", paste(p, collapse = ", "))
    return(NULL)
  }
  list(
    n          = as.integer(p[2]),
    beta        = as.numeric(p[3]),
    shift_size = as.integer(p[4]),
    reg        = p[5],               # "ave" or "fit"
    rep        = as.integer(p[6]),
    file_id    = basename(path)
  )
}

# Read variable-length TSV with base R; no headers; pad shorter rows
read_variable_tsv_base <- function(file_path) {
  lines <- readLines(file_path, warn = FALSE)
  if (!length(lines)) return(NULL)
  split_lines <- strsplit(lines, "\t", fixed = TRUE)
  max_len <- max(vapply(split_lines, length, integer(1)))
  padded <- lapply(split_lines, function(row) { length(row) <- max_len; row })
  df <- as.data.frame(do.call(rbind, padded), stringsAsFactors = FALSE)
  if (ncol(df) < 2) {
    warning("File has fewer than 2 columns: ", file_path)
    return(NULL)
  }
  names(df)[1:2] <- c("generation", "individual_id")
  suppressWarnings({
    df$generation    <- as.integer(df$generation)
    df$individual_id <- as.integer(df$individual_id)
  })
  df
}

# Parse tokens like "mutID:effect" or just "effect" -> numeric effect
tokens_to_effects <- function(x) {
  if (is.null(x) || !length(x)) return(numeric(0))
  x <- x[!is.na(x) & nzchar(x)]
  if (!length(x)) return(numeric(0))
  fx <- sub("^.*?:", "", x, perl = TRUE)   # keep substring after last ":" if present
  suppressWarnings(as.numeric(fx))
}

# ---- LIST FILES ----
file_list <- list.files(
  path = folder,
  pattern = paste0("_gen", gen_filter, "\\.tsv$"),
  full.names = TRUE,
  recursive = TRUE
)

# filter by beta string (1 decimal in filenames)
file_list <- Filter(function(f) any(sapply(target_strs, function(p) grepl(p, f, fixed = TRUE))), file_list)

# ---- READ ALL FILES ----
df_list <- list()
for (file in file_list) {
  raw_df <- read_variable_tsv_base(file)
  if (is.null(raw_df) || !nrow(raw_df)) next

  meta <- extract_effect_metadata(file)
  if (is.null(meta)) next

  # attach metadata (vectorized per row)
  raw_df$rep        <- meta$rep
  raw_df$beta        <- meta$beta
  raw_df$n          <- meta$n
  raw_df$shift_size <- meta$shift_size
  raw_df$reg        <- meta$reg
  raw_df$file_id    <- meta$file_id

  df_list[[length(df_list) + 1]] <- raw_df
}
if (!length(df_list)) stop("No files loaded. Check folder/filters/regex.")

# ---- PROCESS: list-column 'effects' (robust against varying column counts) ----
effects_rows <- lapply(df_list, function(df) {
  # token columns = everything except the known core columns
  core <- c("generation","individual_id","rep","beta","n","shift_size","reg","file_id")
  tok_idx <- which(!(names(df) %in% core))

  eff_list <- if (!length(tok_idx)) {
    replicate(nrow(df), numeric(0), simplify = FALSE)
  } else {
    tmp <- apply(df[, tok_idx, drop = FALSE], 1L, tokens_to_effects)
    if (!is.list(tmp)) as.list(tmp) else tmp
  }

  out <- data.frame(
    generation    = df$generation,
    individual_id = df$individual_id,
    rep           = df$rep,
    beta           = as.numeric(df$beta),
    n             = as.integer(df$n),
    shift_size    = as.integer(df$shift_size),
    reg           = df$reg,
    file_id       = df$file_id,
    stringsAsFactors = FALSE
  )
  out$effects     <- eff_list
  out$num_effects <- vapply(eff_list, length, integer(1))
  out
})

effect_df_listcol <- do.call(rbind, effects_rows)

# ---- OPTIONAL: also build a wide padded matrix (effect_1..K) ----
make_wide <- TRUE
if (make_wide) {
  max_len <- if (nrow(effect_df_listcol)) max(effect_df_listcol$num_effects) else 0L
  if (max_len > 0) {
    effect_mat <- t(vapply(effect_df_listcol$effects, function(v) {
      len <- length(v)
      if (len < max_len) c(v, rep(NA_real_, max_len - len)) else v[seq_len(max_len)]
    }, numeric(max_len)))
    colnames(effect_mat) <- paste0("effect_", seq_len(ncol(effect_mat)))
    effect_df_wide <- cbind(effect_df_listcol[ , !(names(effect_df_listcol) %in% c("effects")), drop=FALSE],
                            as.data.frame(effect_mat, check.names = FALSE))
  } else {
    effect_df_wide <- effect_df_listcol[ , !(names(effect_df_listcol) %in% c("effects")), drop=FALSE]
  }
}

# ---- SAVE ----
# saveRDS(effect_df_listcol, file = file.path(base_data_folder, paste0("ind/effect_df_gen", gen_filter, "_listcol.rds")))
if (make_wide) {
  saveRDS(effect_df_wide,    file = file.path(base_data_folder, paste0("ind/effect_df_gen", gen_filter, "_wide.rds")))
}

```

# load IND data
```{r}
# Load the cleaned effect data
effect_df_wide <- readRDS(
  file.path(base_data_folder, paste0("ind/effect_df_gen", gen_filter, "_wide.rds"))
)
```

## plot EFFECT SIZE histogram 
```{r}
# ---------------------------------------------------------
# EFFECT DISTRIBUTIONS BY beta (from effect_df_wide)
# One PNG per (n, shift_size); averaged over individuals
# Base R only
# ---------------------------------------------------------
plot_ind_effect_dists_by_beta <- function(effect_df_wide,
                                         num_bins = 100,
                                         bin_breaks = NULL,   # if NULL, compute from the group's pooled values
                                         out_subfolder = "ind_effect_dists_by_beta",
                                         regimes = regimes) {

  if (!("reg" %in% names(effect_df_wide))) {
    stop("effect_df_wide must include 'reg' (e.g., 'ave' or 'fit').")
  }

  # effect columns
  xcols <- grep("^effect_", names(effect_df_wide), value = TRUE)
  if (!length(xcols)) stop("No effect_* columns found in effect_df_wide.")

  # helper: average normalized histogram over individuals for a given subset (single beta)
  avg_curve_for_subset <- function(df_block, breaks, num_bins) {
    if (nrow(df_block) == 0) return(rep(NA_real_, num_bins))
    counts_mat <- matrix(NA_real_, nrow = nrow(df_block), ncol = num_bins)
    for (i in seq_len(nrow(df_block))) {
      vals <- suppressWarnings(as.numeric(unlist(df_block[i, xcols])))
      vals <- vals[is.finite(vals)]
      if (!length(vals)) next
      h <- hist(vals, breaks = breaks, plot = FALSE)
      if (sum(h$counts) == 0) next
      counts_mat[i, ] <- h$counts / sum(h$counts)  # normalize per individual
    }
    colMeans(counts_mat, na.rm = TRUE)
  }

  # ---- loop by regime ----
  for (reg_lab in regimes) {
    df_reg <- subset(effect_df_wide, reg == reg_lab)
    if (nrow(df_reg) == 0) next

    # where to save (per regime)
    out_dir <- file.path(base_plot_folder, out_subfolder, paste0("reg_", reg_lab))
    if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

    for (n_val in sort(unique(df_reg$n))) {
      df_n <- subset(df_reg, n == n_val)
      if (nrow(df_n) == 0) next

      for (sh in sort(unique(df_n$shift_size))) {
        df_group <- subset(df_n, shift_size == sh)
        if (nrow(df_group) == 0) next

        # all beta values in this (reg, n, shift) group
        beta_vals <- sort(unique(df_group$beta))
        cols <- hcl.colors(length(beta_vals), palette = "Zissou 1")
        names(cols) <- as.character(beta_vals)

        # Choose bin breaks for THIS plot:
        #   use provided bin_breaks; otherwise compute from pooled effects across all individuals here
        if (is.null(bin_breaks)) {
          pooled <- suppressWarnings(as.numeric(unlist(df_group[, xcols])))
          pooled <- pooled[is.finite(pooled)]
          if (!length(pooled)) next
          rng <- range(pooled)
          if (!is.finite(rng[1]) || !is.finite(rng[2]) || rng[1] == rng[2]) {
            rng <- c(rng[1] - 0.5, rng[2] + 0.5)
          }
          breaks <- seq(rng[1], rng[2], length.out = num_bins + 1)
        } else {
          breaks <- bin_breaks
          # (optional safety) enforce expected length
          if (length(breaks) != num_bins + 1L) {
            warning("Provided bin_breaks length != num_bins + 1; recalculating from range.")
            pooled <- suppressWarnings(as.numeric(unlist(df_group[, xcols])))
            pooled <- pooled[is.finite(pooled)]
            if (!length(pooled)) next
            rng <- range(pooled)
            breaks <- seq(rng[1], rng[2], length.out = num_bins + 1)
          }
        }
        mids <- 0.5 * (breaks[-length(breaks)] + breaks[-1])

        # find a common y-limit across beta averages
        max_y <- 0
        for (beta_val in beta_vals) {
          avg_counts <- avg_curve_for_subset(subset(df_group, beta == beta_val), breaks, num_bins)
          max_y <- max(max_y, avg_counts, na.rm = TRUE)
        }
        if (!is.finite(max_y) || max_y <= 0) max_y <- 1

        # nicer label for shift_size
        title_shift <- if (is.finite(sh) && sh == 0) "data-driven" else paste0("shift_size = ", sh)
        file_shift  <- if (is.finite(sh) && sh == 0) "dataDriven"  else paste0("shift_", sh)

        # open PNG
        fname <- paste0("ind_effect_dists_reg_", reg_lab, "_n_", n_val, "_", file_shift, ".png")
        png(file.path(out_dir, fname), width = 1000, height = 700)
        par(mar = c(4.5, 4.5, 3.5, 1) + 0.1)

        # base empty plot
        plot(NULL,
             xlim = range(breaks), ylim = c(0, max_y),
             xlab = "Effect size", ylab = "Proportion",
             main = paste0("Effect distributions | reg = ", reg_lab,
                           " | n = ", n_val, " | ", title_shift))

        # draw one averaged curve per beta
        for (beta_val in beta_vals) {
          avg_counts <- avg_curve_for_subset(subset(df_group, beta == beta_val), breaks, num_bins)
          if (all(is.na(avg_counts))) next
          lines(mids, avg_counts, col = cols[as.character(beta_val)], lwd = 2)
        }

        legend("topright",
               legend = paste0("beta=", beta_vals),
               col = cols[as.character(beta_vals)],
               lty = 1, lwd = 2, cex = 0.9, bg = "white")

        dev.off()
      }
    }
  }
}

# ---- Run it ----
plot_ind_effect_dists_by_beta(
  effect_df_wide,
  num_bins = 40,
  bin_breaks = seq(-4, 4, by = 0.2),  # 8 / 40 = 0.2
  out_subfolder = "ind_effect_dists_by_beta",
  regimes = regimes  # e.g., c("ave","fit")
)
```


# load MUT data
```{r}
# ---------------------------------------------
# MUT files → per-generation mutation counts
# - no headers
# - variable-length rows/columns
# - odd rows: mutation IDs ... <gen>
# - even rows: effect sizes (ignored)
# ---------------------------------------------

mut_folder <- file.path(base_data_folder, "mut")

mut_files <- list.files(
  path = mut_folder,
  pattern = "\\.tsv$",
  full.names = TRUE,
  recursive = TRUE
)

# Filename pattern (UPDATED):
#   mut/n_{n}_beta_{beta}_sz_{shift}_reg_{inv|var}_{rep}.tsv
extract_mut_metadata <- function(path) {
  rx <- "mut/n_(\\d+)_beta_(-?[0-9.]+)_sz_(\\d+)_reg_(inv|var)_(\\d+)\\.tsv"
  m  <- regexec(rx, path)
  p  <- regmatches(path, m)[[1]]
  if (length(p) != 6) {
    warning("Could not extract metadata from path: ", path, " | parts: ", paste(p, collapse=", "))
    return(NULL)
  }
  list(
    n          = as.integer(p[2]),
    beta        = as.numeric(p[3]),
    shift_size = as.integer(p[4]),
    reg        = p[5],                 # "ave" or "fit"
    rep        = as.integer(p[6]),
    file_id    = basename(path)
  )
}

# Utility: find index of the last non-empty, purely-integer token
.last_integer_token_idx <- function(tokens) {
  if (!length(tokens)) return(NA_integer_)
  nz <- which(nzchar(tokens))
  if (!length(nz)) return(NA_integer_)
  toks <- tokens[nz]
  for (k in seq_along(toks)) {
    idx <- length(toks) - k + 1L
    if (grepl("^-?\\d+$", toks[idx])) {
      return(nz[idx])  # map back to original position
    }
  }
  NA_integer_
}

count_mutations_in_file <- function(file) {
  lines <- readLines(file, warn = FALSE)
  if (!length(lines)) return(NULL)

  meta <- extract_mut_metadata(file)
  if (is.null(meta)) return(NULL)

  out <- vector("list", length = ceiling(length(lines) / 2))
  oi <- 0L

  # process odd rows only: 1,3,5,...
  for (i in seq.int(1L, length(lines), by = 2L)) {
    raw <- lines[i]
    if (!nzchar(raw)) next

    toks <- strsplit(raw, "\t", fixed = TRUE)[[1]]
    toks <- trimws(toks, which = "both")

    gen_pos <- .last_integer_token_idx(toks)
    if (is.na(gen_pos)) {
      warning("No numeric generation token found (odd row ", i, ") in: ", file)
      next
    }
    gen <- suppressWarnings(as.integer(toks[gen_pos]))
    if (!is.finite(gen)) next

    # Everything before gen_pos are mutation IDs (variable count, may include blanks)
    id_tokens <- if (gen_pos > 1L) toks[1:(gen_pos - 1L)] else character(0)
    mut_count <- sum(nzchar(id_tokens))

    oi <- oi + 1L
    out[[oi]] <- data.frame(
      n          = meta$n,
      beta        = meta$beta,
      shift_size = meta$shift_size,
      reg        = meta$reg,
      rep        = meta$rep,
      file_id    = meta$file_id,
      generation = gen,
      mut_count  = mut_count,
      stringsAsFactors = FALSE
    )
  }

  if (oi == 0L) return(NULL)
  do.call(rbind, out[seq_len(oi)])
}

# Run over all files
mut_count_df <- do.call(rbind, lapply(mut_files, count_mutations_in_file))

# Optional tidy-up
if (!is.null(mut_count_df) && nrow(mut_count_df)) {
  mut_count_df <- mut_count_df[order(mut_count_df$n,
                                     mut_count_df$beta,
                                     mut_count_df$reg,
                                     mut_count_df$shift_size,
                                     mut_count_df$rep,
                                     mut_count_df$generation), ]
}

```

## plot number of alleles over beta and n
```{r}
# ------------------------------------------------------
# Mutations vs beta (gen = 10000), one PNG per (n, shift_size)
# Base R only
# ------------------------------------------------------
plot_mut_counts_over_beta <- function(mut_count_df,
                                     gen_target = 10000L,
                                     out_subfolder = "mut_counts_by_beta",
                                     regimes = regimes) {
  if (!("reg" %in% names(mut_count_df))) {
    stop("mut_count_df must include 'reg' (e.g., 'ave' or 'fit').")
  }

  rep_col  <- adjustcolor("steelblue", alpha.f = 0.35)
  mean_col <- "steelblue4"

  for (reg_lab in regimes) {
    d_reg <- subset(mut_count_df, reg == reg_lab & generation == gen_target)
    if (nrow(d_reg) == 0) {
      warning("No rows at generation ", gen_target, " for reg=", reg_lab, " in mut_count_df.")
      next
    }

    out_dir <- file.path(base_plot_folder, out_subfolder, paste0("reg_", reg_lab))
    if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

    for (n_val in sort(unique(d_reg$n))) {
      d_n <- subset(d_reg, n == n_val)
      if (nrow(d_n) == 0) next

      for (sh in sort(unique(d_n$shift_size))) {
        d <- subset(d_n, shift_size == sh)
        if (nrow(d) == 0) next

        beta_grid <- sort(unique(d$beta))
        reps     <- sort(unique(d$rep))

        rep_series <- lapply(reps, function(r) {
          yv <- rep(NA_real_, length(beta_grid))
          rows <- d[d$rep == r, c("beta","mut_count")]
          if (nrow(rows)) {
            rows$beta <- as.numeric(rows$beta)
            agg <- aggregate(mut_count ~ beta, data = rows, FUN = mean)
            idx <- match(agg$beta, beta_grid)
            yv[idx] <- agg$mut_count
          }
          yv
        })
        names(rep_series) <- as.character(reps)

        if (length(rep_series)) {
          mat <- do.call(rbind, rep_series)
          mean_series <- apply(mat, 2L, function(col) mean(col, na.rm = TRUE))
        } else {
          mean_series <- rep(NA_real_, length(beta_grid))
        }

        y_all <- c(unlist(rep_series, use.names = FALSE), mean_series)
        y_all <- y_all[is.finite(y_all)]
        if (!length(y_all)) next
        y_min <- min(y_all); y_max <- max(y_all)
        if (y_min == y_max) { y_min <- y_min - 0.5; y_max <- y_max + 0.5 }

        # nicer label for shift_size
        title_shift <- if (is.finite(sh) && sh == 0) "data-driven" else paste0("shift_size = ", sh)
        file_shift  <- if (is.finite(sh) && sh == 0) "dataDriven"  else paste0("shift_", sh)

        fname <- paste0("mut_count_over_beta_reg_", reg_lab,
                        "_n_", n_val, "_", file_shift, "_gen", gen_target, ".png")
        png(file.path(out_dir, fname), width = 1000, height = 700)
        par(mar = c(4.5, 4.5, 3.5, 1) + 0.1)

        plot(NA,
             xlim = range(beta_grid), ylim = c(y_min, y_max),
             xlab = expression(beta), ylab = "Mutation count",
             main = paste0("Mutations vs beta | reg = ", reg_lab,
                           " | n = ", n_val, " | ", title_shift,
                           " | gen = ", gen_target),
             xaxt = "n")
        axis(1, at = beta_grid, labels = formatC(beta_grid, format = "f", digits = 1))

        if (length(rep_series)) {
          for (i in seq_along(rep_series)) {
            yv <- rep_series[[i]]
            lines(beta_grid, yv, col = rep_col, lwd = 1)
            points(beta_grid, yv, pch = 16, cex = 0.7, col = rep_col)
          }
        }

        lines(beta_grid, mean_series, col = mean_col, lwd = 2.5)
        points(beta_grid, mean_series, pch = 16, cex = 1, col = mean_col)

        legend("topleft", inset = 0.02,
               legend = c("Replicate", "Across-rep mean"),
               col = c(rep_col, mean_col), lty = c(1,1),
               lwd = c(1, 2.5), pch = c(16,16),
               pt.cex = c(0.7, 1.0), bty = "n", cex = 0.9)

        dev.off()
      }
    }
  }
}

# ---- Run ----
plot_mut_counts_over_beta(
  mut_count_df,
  gen_target = 10000L,
  out_subfolder = "mut_counts_by_beta",
  regimes = regimes  # e.g., c("ave","fit")
)

```

## plot population level mut distribution
```{r}
# --- Config (bins) ---
num_bins   <- 60
bin_breaks <- seq(-6, 6, length.out = num_bins + 1)
bin_mids   <- 0.5 * (bin_breaks[-1] + bin_breaks[-length(bin_breaks)])

# --- Files ---
mut_folder <- file.path(base_data_folder, "mut")
mut_files <- list.files(mut_folder, pattern = "\\.tsv$", full.names = TRUE, recursive = TRUE)

# --- Filename metadata (UPDATED):
# mut/n_{n}_beta_{beta}_sz_{shift}_reg_{inv|var}_{rep}.tsv
extract_mut_metadata <- function(path) {
  rx <- "mut/n_(\\d+)_beta_(-?[0-9.]+)_sz_(\\d+)_reg_(inv|var)_(\\d+)\\.tsv"
  m  <- regexec(rx, path)
  p  <- regmatches(path, m)[[1]]
  if (length(p) != 6) return(NULL)
  list(
    n          = as.integer(p[2]),
    beta        = as.numeric(p[3]),
    shift_size = as.integer(p[4]),
    reg        = p[5],                 # "ave" or "fit"
    rep        = as.integer(p[6]),
    file_id    = basename(path)
  )
}

# --- Helpers to parse lines with variable length & no headers ---
.last_integer_token_idx <- function(tokens) {
  if (!length(tokens)) return(NA_integer_)
  nz <- which(nzchar(tokens))
  if (!length(nz)) return(NA_integer_)
  toks <- tokens[nz]
  for (k in seq_along(toks)) {
    idx <- length(toks) - k + 1L
    if (grepl("^-?\\d+$", toks[idx])) return(nz[idx])
  }
  NA_integer_
}

# --- Build per-rep LONG table of normalized histograms ---
# One row per (file × generation × bin)
# Columns: n, beta, shift_size, reg, rep, file_id, generation, bin_mid, prop
mut_hist_long <- (function() {
  out <- vector("list", length(mut_files))
  oi  <- 0L

  for (file in mut_files) {
    meta <- extract_mut_metadata(file)
    if (is.null(meta)) next

    lines <- readLines(file, warn = FALSE)
    if (!length(lines)) next

    # Walk odd/even pairs
    for (i in seq.int(1L, length(lines), by = 2L)) {
      # ---- odd row: IDs ----
      ids_row <- lines[i]
      if (!nzchar(ids_row)) next
      ids_toks <- strsplit(ids_row, "\t", fixed = TRUE)[[1]]
      ids_toks <- trimws(ids_toks)
      gen_pos1 <- .last_integer_token_idx(ids_toks)
      if (is.na(gen_pos1)) next
      gen1 <- suppressWarnings(as.integer(ids_toks[gen_pos1]))
      if (!is.finite(gen1)) next

      # ---- even row: effects ----
      if (i + 1L > length(lines)) next
      eff_row <- lines[i + 1L]
      eff_toks <- strsplit(eff_row, "\t", fixed = TRUE)[[1]]
      eff_toks <- trimws(eff_toks)
      gen_pos2 <- .last_integer_token_idx(eff_toks)
      gen2 <- if (!is.na(gen_pos2)) suppressWarnings(as.integer(eff_toks[gen_pos2])) else NA_integer_
      # prefer even-row gen if valid; else use odd-row gen
      gen <- if (is.finite(gen2)) gen2 else gen1
      if (!is.finite(gen)) next

      # effect tokens are everything before the gen token on the even row
      eff_tokens <- if (!is.na(gen_pos2) && gen_pos2 > 1L) eff_toks[1:(gen_pos2 - 1L)] else character(0)
      # fallback: if even row malformed, try IDs row length
      if (!length(eff_tokens) && gen_pos1 > 1L) eff_tokens <- ids_toks[1:(gen_pos1 - 1L)]

      eff_vals <- suppressWarnings(as.numeric(eff_tokens))
      eff_vals <- eff_vals[is.finite(eff_vals)]
      if (!length(eff_vals)) next  # no effects → skip this generation for this rep

      h <- hist(eff_vals, breaks = bin_breaks, plot = FALSE)
      if (sum(h$counts) == 0) next
      prop <- h$counts / sum(h$counts)

      # add long rows (one per bin)
      df_piece <- data.frame(
        n          = meta$n,
        beta        = meta$beta,
        shift_size = meta$shift_size,
        reg        = meta$reg,
        rep        = meta$rep,
        file_id    = meta$file_id,
        generation = gen,
        bin_mid    = bin_mids,
        prop       = prop,
        stringsAsFactors = FALSE
      )

      oi <- oi + 1L
      out[[oi]] <- df_piece
    }
  }
  if (oi == 0L) return(data.frame())
  do.call(rbind, out[seq_len(oi)])
})()

# --- Average across reps (mean proportion per bin) ---
# Gives one row per (n, beta, shift_size, reg, generation, bin_mid)
if (nrow(mut_hist_long)) {
  mut_hist_mean <- aggregate(
    prop ~ n + beta + shift_size + reg + generation + bin_mid,
    data = mut_hist_long,
    FUN = function(x) mean(x, na.rm = TRUE)
  )
  # (optional) how many reps contributed to each mean
  mut_hist_n <- aggregate(
    prop ~ n + beta + shift_size + reg + generation + bin_mid,
    data = mut_hist_long,
    FUN = function(x) sum(is.finite(x))
  )
  names(mut_hist_n)[names(mut_hist_n) == "prop"] <- "n_reps"
  mut_hist_mean <- merge(
    mut_hist_mean, mut_hist_n,
    by = c("n","beta","shift_size","reg","generation","bin_mid"),
    all.x = TRUE, sort = FALSE
  )
} else {
  mut_hist_mean <- data.frame()
}

```

```{r}
# ---------------------------------------------
# Plot averaged mut effect-size hists for gen 10000 and 10005
# One PNG per (n, shift_size, generation); lines = beta
# ---------------------------------------------
plot_mut_hist_two_gens <- function(mut_hist_mean,
                                   gens = c(10000, 10005),
                                   out_subfolder = "mut_effect_hist_avg_two_gens",
                                   regimes = regimes) {
  if (!nrow(mut_hist_mean)) {
    warning("mut_hist_mean is empty.")
    return(invisible(NULL))
  }
  if (!("reg" %in% names(mut_hist_mean))) {
    stop("mut_hist_mean must include 'reg' (e.g., 'ave' or 'fit').")
  }

  for (reg_lab in regimes) {
    df_reg <- subset(mut_hist_mean, reg == reg_lab)
    if (nrow(df_reg) == 0) next

    out_dir <- file.path(base_plot_folder, out_subfolder, paste0("reg_", reg_lab))
    if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

    for (n_val in sort(unique(df_reg$n))) {
      df_n <- subset(df_reg, n == n_val)
      if (nrow(df_n) == 0) next

      for (sh in sort(unique(df_n$shift_size))) {
        df_ns <- subset(df_n, shift_size == sh)
        if (nrow(df_ns) == 0) next

        # Nice label/filename piece for shift_size
        title_shift <- if (is.finite(sh) && sh == 0) "data-driven" else paste0("shift_size = ", sh)
        file_shift  <- if (is.finite(sh) && sh == 0) "dataDriven"  else paste0("shift_", sh)

        for (g in gens) {
          d <- subset(df_ns, generation == g)
          if (nrow(d) == 0) next

          beta_vals <- sort(unique(d$beta))
          cols <- hcl.colors(length(beta_vals), palette = "Zissou 1")
          names(cols) <- as.character(beta_vals)

          # y-limit from data
          y_max <- max(d$prop, na.rm = TRUE)
          if (!is.finite(y_max) || y_max <= 0) y_max <- 1

          # x-limits from bin mids (expand slightly if we can estimate bin width)
          mids_all <- sort(unique(d$bin_mid))
          if (length(mids_all) > 1) {
            bw <- min(diff(mids_all))
            xlim <- c(min(mids_all) - 0.5 * bw, max(mids_all) + 0.5 * bw)
          } else {
            xlim <- range(mids_all)
          }

          # File + device
          fname <- paste0("mut_avg_hist_reg_", reg_lab, "_n_", n_val, "_", file_shift, "_gen", g, ".png")
          png(file.path(out_dir, fname), width = 1000, height = 700)
          par(mar = c(4.5, 4.5, 3.5, 1) + 0.1)

          plot(NULL, xlim = xlim, ylim = c(0, y_max),
               xlab = "Effect size", ylab = "Proportion",
               main = paste0("Unique-mutation effects (avg over reps)\n",
                             "reg = ", reg_lab, " | n = ", n_val, " | ",
                             title_shift, " | gen = ", g))

          # Draw one averaged curve per beta
          for (beta_val in beta_vals) {
            dd <- d[d$beta == beta_val, ]
            dd <- dd[order(dd$bin_mid), ]
            if (!nrow(dd)) next
            lines(dd$bin_mid, dd$prop, col = cols[as.character(beta_val)], lwd = 2)
          }

          legend("topright",
                 legend = paste0("beta=", beta_vals),
                 col = cols[as.character(beta_vals)],
                 lty = 1, lwd = 2, cex = 0.9, bg = "white")

          dev.off()
        }
      }
    }
  }
}

# Run
plot_mut_hist_two_gens(
  mut_hist_mean,
  gens = c(10000, 10005, 10015),
  out_subfolder = "mut_effect_hist_pop",
  regimes = regimes  # e.g., c("ave","fit")
)

```
