---
title: "plotting functions"
author: "Andrea Chen"
date: "`r Sys.Date()`"
output: pdf_document
---
```{r setup, include=FALSE}
.compute_center <- function(df_block) {
    xcols <- grep("^[0-9]+$", names(df_block))
    if (!length(xcols) || nrow(df_block) == 0) return(NA_real_)
    vals <- suppressWarnings(as.numeric(unlist(df_block[, xcols])))
    vals <- vals[is.finite(vals)]
    if (!length(vals)) return(NA_real_)
    mean(vals)
}

.avg_hist_curve_with_breaks <- function(df_block, breaks, num_bins) {
    if (nrow(df_block) == 0) return(rep(NA_real_, num_bins))
    xcols <- grep("^[0-9]+$", names(df_block))
    reps  <- sort(unique(df_block$rep))
    if (!length(xcols) || !length(reps)) return(rep(NA_real_, num_bins))
    counts_mat <- matrix(NA_real_, nrow = length(reps), ncol = num_bins)
    for (i in seq_along(reps)) {
        row_i <- subset(df_block, rep == reps[i])[1, ]
        vals <- suppressWarnings(as.numeric(as.vector(unlist(row_i[, xcols]))))
        vals <- vals[is.finite(vals)]
        if (!length(vals)) next
        vals <- vals[vals > min(breaks) & vals < max(breaks)]
        h <- hist(vals, breaks = breaks, plot = FALSE)
        if (sum(h$counts) == 0) next
        counts_mat[i, ] <- h$counts / sum(h$counts)
    }
    colMeans(counts_mat, na.rm = TRUE)
}

.compute_series <- function(df_panel, tick_seq) {
    df_sub <- df_panel

    # Coerce
    dif_z_opt_num <- suppressWarnings(as.numeric(df_sub$dif_z_opt))
    z_mean_num    <- suppressWarnings(as.numeric(df_sub$z_mean))
    df_sub$tick   <- suppressWarnings(as.integer(df_sub$tick))
    df_sub$rep    <- suppressWarnings(as.integer(df_sub$rep))

    # Base y from dif_z_opt
    y <- dif_z_opt_num

    # ----- Dynamic special-case at tick 9999: y <- opt_rep_at_10000 - z_mean_9999 -----
    # Use per-rep optimum at tick 10000 if available; otherwise skip replacement for that rep
    if ("optimum" %in% names(df_sub)) {
        opt_num <- suppressWarnings(as.numeric(df_sub$optimum))
        # collect per-rep optimum at tick 10000
        rows_opt <- is.finite(opt_num) & is.finite(df_sub$rep) & (df_sub$tick == 10000)
        if (any(rows_opt)) {
            opt_tab <- tapply(opt_num[rows_opt], df_sub$rep[rows_opt], function(v) mean(v, na.rm = TRUE))
            # map per-row rep -> optimum
            rep_ids   <- as.integer(names(opt_tab))
            match_idx <- match(df_sub$rep, rep_ids)
            rep_opt   <- rep(NA_real_, nrow(df_sub))
            good_m    <- !is.na(match_idx)
            rep_opt[good_m] <- as.numeric(opt_tab)[match_idx[good_m]]

            # apply at tick 9999 where we have z_mean and rep_opt
            idx_9999 <- (df_sub$tick == 9999) & is.finite(z_mean_num) & is.finite(rep_opt)
            y[idx_9999] <- rep_opt[idx_9999] - z_mean_num[idx_9999]
        }
    }

    df_sub$y <- y

    # Keep finite rows
    df_sub <- df_sub[is.finite(df_sub$y) & is.finite(df_sub$tick) & is.finite(df_sub$rep), , drop = FALSE]
    if (!nrow(df_sub)) return(list(reps = list(), mean = rep(NA_real_, length(tick_seq)), present_ticks = integer(0)))

    # Aggregate by tick,rep
    agg <- aggregate(y ~ tick + rep, data = df_sub, FUN = mean)
    reps <- sort(unique(agg$rep))

    rep_series <- lapply(reps, function(r) {
        yv <- rep(NA_real_, length(tick_seq))
        rows <- agg[agg$rep == r & agg$tick %in% tick_seq, , drop = FALSE]
        if (nrow(rows)) {
            idx <- match(rows$tick, tick_seq)
            yv[idx] <- rows$y
        }
        yv
    })
    names(rep_series) <- as.character(reps)

    if (length(rep_series)) {
        mat <- do.call(rbind, rep_series)
        mean_series  <- apply(mat, 2L, function(col) mean(col, na.rm = TRUE))
        present_ticks <- tick_seq[colSums(!is.na(mat)) > 0]
    } else {
        mean_series <- rep(NA_real_, length(tick_seq))
        present_ticks <- integer(0)
    }

    list(reps = rep_series, mean = mean_series, present_ticks = present_ticks)
}

# ---------- Exponential-decay fit helpers ----------
# Model: y(x) = c0 + c1 * exp( -k * (x - t0) ), with t0 = min(x) fixed
.fit_exp_decay <- function(x, y) {
    x <- as.numeric(x); y <- as.numeric(y)
    ok <- is.finite(x) & is.finite(y)
    x <- x[ok]; y <- y[ok]
    if (length(x) < 5) {
        return(list(success = FALSE, params = NA, x_fit = x, y_fit = rep(NA_real_, length(x)), r2 = NA_real_))
    }
    ord <- order(x); x <- x[ord]; y <- y[ord]
    t0 <- min(x)

    tail_n <- max(5L, ceiling(0.2 * length(y)))
    c0_guess <- median(tail(y, tail_n), na.rm = TRUE)
    c1_guess <- max(1e-8, y[1] - c0_guess)
    k_guess  <- 0.01

    y_shift <- pmax(y - c0_guess, 1e-8)
    lm_fit <- try(suppressWarnings(lm(log(y_shift) ~ I(x - t0))), silent = TRUE)
    if (!inherits(lm_fit, "try-error")) {
        k_guess  <- max(1e-6, -coef(lm_fit)[2])
        c1_guess <- max(1e-8, exp(coef(lm_fit)[1]))
    }

    df <- data.frame(x = x, y = y)
    nls_fit <- try(
        suppressWarnings(
        nls(y ~ c0 + c1 * exp(-k * (x - t0)),
            data = df,
            start = list(c0 = c0_guess, c1 = c1_guess, k = k_guess),
            control = list(maxiter = 200, warnOnly = TRUE))
        ),
        silent = TRUE
    )

    if (inherits(nls_fit, "try-error")) {
        if (is.finite(k_guess) && is.finite(c1_guess) && is.finite(c0_guess)) {
            c0 <- c0_guess; c1 <- c1_guess; k <- k_guess
            y_hat <- c0 + c1 * exp(-k * (x - t0))
            sse <- sum((y - y_hat)^2, na.rm = TRUE)
            sst <- sum((y - mean(y, na.rm = TRUE))^2, na.rm = TRUE)
            r2  <- if (sst > 0) 1 - sse/sst else NA_real_
            return(list(success = TRUE, params = c(c0 = c0, c1 = c1, k = k, t0 = t0),
                        x_fit = x, y_fit = y_hat, r2 = r2))
        } else {
            return(list(success = FALSE, params = NA, x_fit = x, y_fit = rep(NA_real_, length(x)), r2 = NA_real_))
        }
    }

    co <- coef(nls_fit)
    c0 <- unname(co["c0"]); c1 <- unname(co["c1"]); k <- unname(co["k"])
    y_hat <- c0 + c1 * exp(-k * (x - t0))
    sse <- sum((y - y_hat)^2, na.rm = TRUE)
    sst <- sum((y - mean(y, na.rm = TRUE))^2, na.rm = TRUE)
    r2  <- if (sst > 0) 1 - sse/sst else NA_real_

    list(success = TRUE, params = c(c0 = c0, c1 = c1, k = k, t0 = t0),
        x_fit = x, y_fit = y_hat, r2 = r2)
}

.fmt <- function(x, d = 3) formatC(x, format = "f", digits = d)

```


# plotting function for genotypic distribution
```{r}
plot_genotype_multi_by_psi <- function(genotype_df,
                                       out_subfolder = "genotype_multi_by_psi_genbins",
                                       gen_seq = 10000:10005,
                                       num_bins = num_bins,
                                       bin_width = bin_width,
                                       half_span = half_span,
                                       regimes = regimes,
                                       single_panel = TRUE,
                                       include_pre_selection = FALSE,
                                       pre_selection_gen = 9999) { 
    include_pre_selection <- include_pre_selection & !(pre_selection_gen %in% gen_seq)
    # Loop over regimes
    for (reg_lab in regimes) {
        df_reg <- subset(genotype_df, reg == reg_lab)
        if (nrow(df_reg) == 0) next

        # Separate subfolder per regime
        out_dir <- file.path(base_plot_folder, out_subfolder, paste0("model_", reg_lab))
        if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

        for (n_val in plot_n) {
            df_n <- subset(df_reg, n == n_val)
            if (nrow(df_n) == 0) next

            shift_keys <- paste0("shift=", plot_shift_sizes)
            all_vals <- plot_psi

            for (sk in shift_keys) {
                df_group <- subset(df_n, shift_size == as.numeric(sub("shift=", "", sk)))
                
                if (nrow(df_group) == 0) next

                # Common y-limit and x-range across all psi & gens
                max_y <- 0
                x_min <- Inf; x_max <- -Inf
                for (val in all_vals) {
                    df_p <- subset(df_group, psi == val)
                    
                    if (nrow(df_p) == 0) next
                    for (g in gen_seq) {
                        df_pg <- subset(df_p, generation == g)
                        center <- .compute_center(df_pg)
                        if (!is.finite(center)) next
                        breaks_g <- seq(center - half_span, center + half_span, by = bin_width)
                        avg_counts <- .avg_hist_curve_with_breaks(df_pg, breaks_g, num_bins)
                        max_y <- max(max_y, avg_counts, na.rm = TRUE)
                        x_min <- min(x_min, min(breaks_g), na.rm = TRUE)
                        x_max <- max(x_max, max(breaks_g), na.rm = TRUE)
                    }
                    if (include_pre_selection) {
                        df_pre <- subset(df_p, generation == pre_selection_gen)
                        center <- .compute_center(df_pre)
                        if (is.finite(center)) {
                            breaks_pre <- seq(center - half_span, center + half_span, by = bin_width)
                            avg_counts_pre <- .avg_hist_curve_with_breaks(df_pre, breaks_pre, num_bins)
                            max_y <- max(max_y, avg_counts_pre, na.rm = TRUE)
                            x_min <- min(x_min, min(breaks_pre), na.rm = TRUE)
                            x_max <- max(x_max, max(breaks_pre), na.rm = TRUE)
                        }
                    }
                }
                if (!is.finite(max_y) || max_y <= 0) max_y <- 1
                if (!is.finite(x_min) || !is.finite(x_max) || x_min >= x_max) {
                    x_min <- -half_span; x_max <- half_span
                }

                if (single_panel & length(gen_seq) == 1) {
                    # Single panel
                    png_w <- 9; png_h <- 7
                    title_suffix <- paste0("shift_size = ", as.numeric(sub("shift=", "", sk)))
                    if (include_pre_selection) {
                        out_name <- paste0("n_", n_val, "_", gsub("[ =]", "", title_suffix), "_pre.pdf")
                    } else{
                        out_name <- paste0("n_", n_val, "_", gsub("[ =]", "", title_suffix), ".pdf")
                    }
                    pdf(file.path(out_dir, out_name), width = png_w, height = png_h)
                    op <- par(mfrow = c(1, 1), mar = c(4, 4, 3, 1) + 0.1, oma = c(0, 0, 3.5, 0))

                    plot(NULL,
                        xlim = c(x_min, x_max), ylim = c(0, max_y),
                        xlab = "Genotype Value", ylab = "Proportion",
                        main = paste0("genotype distributions | model = ", reg_lab,
                            " | n = ", n_val, " | ", title_suffix))

                    # curve(dnorm(x, mean = as.numeric(sub("shift=", "", sk)), sd = sqrt(2000)),
                    #     add = TRUE, col = "black", lty = 2, lwd = 2)
                    curve(dnorm(x, mean = 0, sd = sqrt(2000)),
                        add = TRUE, col = "black", lty = 2, lwd = 2)

                    val_col <- hcl.colors(length(all_vals), palette = hcl_color_palette)
                    names(val_col) <- as.character(all_vals)
                    for (val in all_vals) {
                        df_p <-  subset(df_group, psi == val)
                        
                        if (nrow(df_p) == 0) next

                        g= gen_seq[1]  # only one generation
                        df_pg <- subset(df_p, generation == g)
                        center <- .compute_center(df_pg)
                        if (!is.finite(center)) next
                        breaks_g <- seq(center - half_span, center + half_span, by = bin_width)
                        mids_g   <- 0.5 * (breaks_g[-length(breaks_g)] + breaks_g[-1])
                        avg_counts <- .avg_hist_curve_with_breaks(df_pg, breaks_g, num_bins)
                        if (all(is.na(avg_counts))) next
                        lines(mids_g, avg_counts, col = val_col[as.character(val)], lwd = 2)

                        if (include_pre_selection) {
                            df_pre <- subset(df_p, generation == pre_selection_gen)
                            center <- .compute_center(df_pre)
                            if (is.finite(center)) {
                                breaks_pre <- seq(center - half_span, center + half_span, by = bin_width)
                                mids_pre   <- 0.5 * (breaks_pre[-length(breaks_pre)] + breaks_pre[-1])
                                avg_counts_pre <- .avg_hist_curve_with_breaks(df_pre, breaks_pre, num_bins)
                                if (!all(is.na(avg_counts_pre))) {
                                    lines(mids_pre, avg_counts_pre,
                                        col = adjustcolor(val_col[as.character(val)], alpha.f = 0.5),
                                        lwd = 2, lty = 1)
                                }
                            }
                        }
                    }

                    legend_text = paste0("psi=", all_vals)
                    legend_text = if (include_pre_selection) {
                        c(legend_text, "Fitness Func", "Pre-selection")
                    } else {
                        c(legend_text, "Fitness Func")
                    }
                    col_lab <- if (include_pre_selection) {
                        c(val_col[as.character(all_vals)], "black", adjustcolor("black", alpha.f = 0.5))
                    } else {
                        c(val_col[as.character(all_vals)], "black")
                    }
                    lty = if (include_pre_selection) {
                        c(rep(1, length(all_vals)), 2, 1)
                    } else {
                        c(rep(1, length(all_vals)), 2)
                    }
                    legend("topright",
                            legend = legend_text,
                            col = col_lab,
                            lty = lty, lwd = 2, cex = 0.8, bg = "white")
                    par(op)
                    dev.off()
                }else if (single_panel & length(gen_seq) > 1)
                {
                    # Single panel
                    gap <- gen_seq[3] - gen_seq[2]
                    png_w <- 9; png_h <- 7
                    title_suffix <- paste0("shift_size = ", as.numeric(sub("shift=", "", sk)))
                    if (include_pre_selection) {
                        out_name <- paste0("n_", n_val, "_", gsub("[ =]", "", title_suffix), "by_", gap, "_pre.pdf")
                    } else{
                        out_name <- paste0("n_", n_val, "_", gsub("[ =]", "", title_suffix), "by_", gap, ".pdf")
                    }
                    pdf(file.path(out_dir, out_name), width = png_w, height = png_h)
                    op <- par(mfrow = c(1, 1), mar = c(4, 4, 3, 1) + 0.1, oma = c(0, 0, 3.5, 0))

                    plot(NULL,
                        xlim = c(x_min, x_max), ylim = c(0, max_y),
                        xlab = "Genotype Value", ylab = "Proportion",
                        main = paste0("Genotype distributions | model = ", reg_lab,
                            " | n = ", n_val, " | ", title_suffix))

                    # curve(dnorm(x, mean = as.numeric(sub("shift=", "", sk)), sd = sqrt(2000)),
                    #     add = TRUE, col = "black", lty = 2, lwd = 2)
                    curve(dnorm(x, mean = 0, sd = sqrt(2000)),
                        add = TRUE, col = "black", lty = 2, lwd = 2)

                    val_col <- hcl.colors(length(all_vals), palette = hcl_color_palette)
                    names(val_col) <- as.character(all_vals)
                    alphas <- seq(0.3, 1.0, length.out = length(gen_seq))
                    names(alphas) <- as.character(gen_seq)
                    
                    for (val in all_vals) {
                        df_p <- subset(df_group, psi == val)
                        if (nrow(df_p) == 0) next

                        base_col <- val_col[as.character(val)]

                        for (g in gen_seq) {
                            df_pg <- subset(df_p, generation == g)
                            center <- .compute_center(df_pg)
                            if (!is.finite(center)) next

                            breaks_g <- seq(center - half_span, center + half_span, by = bin_width)
                            mids_g   <- 0.5 * (breaks_g[-length(breaks_g)] + breaks_g[-1])
                            avg_counts <- .avg_hist_curve_with_breaks(df_pg, breaks_g, num_bins)
                            if (all(is.na(avg_counts))) next

                            lines(mids_g, avg_counts,
                                col = adjustcolor(base_col, alpha.f = alphas[as.character(g)]),
                                lwd = 2)
                        }
                        
                        if (include_pre_selection) {
                            df_pre <- subset(df_p, generation == pre_selection_gen)
                            center <- .compute_center(df_pre)
                            if (is.finite(center)) {
                                breaks_pre <- seq(center - half_span, center + half_span, by = bin_width)
                                mids_pre   <- 0.5 * (breaks_pre[-length(breaks_pre)] + breaks_pre[-1])
                                avg_counts_pre <- .avg_hist_curve_with_breaks(df_pre, breaks_pre, num_bins)
                                if (!all(is.na(avg_counts_pre))) {
                                    lines(mids_pre, avg_counts_pre,
                                        col = adjustcolor(val_col[as.character(val)]),
                                        lwd = 2, lty = 5)
                                }
                            }
                        }
                    }

                    legend_text = paste0("psi=", all_vals)
                    
                    legend_text = if (include_pre_selection) {
                        c(legend_text, "Fitness Func", "Pre-selection")
                    } else {
                        c(legend_text, "Fitness Func")
                    }
                    col_lab <- if (include_pre_selection) {
                        c(val_col[as.character(all_vals)], "black", "black")
                    } else {
                        c(val_col[as.character(all_vals)], "black")
                    }
                    lty = if (include_pre_selection) {
                        c(rep(1, length(all_vals)), 2, 5)
                    } else {
                        c(rep(1, length(all_vals)), 2)
                    }
                    legend("topright",
                            legend = legend_text,
                            col = col_lab,
                            lty = lty, lwd = 2, cex = 0.8, bg = "white")
                    early <- head(gen_seq, 1); late <- tail(gen_seq, 1)
                    legend("topleft",
                            legend = c(paste0("gen ", early), paste0("gen ", late), "later = darker"),
                            col = c(adjustcolor("black", alpha.f = alphas[as.character(early)]),
                                    adjustcolor("black", alpha.f = alphas[as.character(late)]),
                                    NA),
                            lty = c(1,1,NA), lwd = c(2,2,NA), cex = 0.8, bg = "white", bty = "o")
                    
                    par(op)
                    dev.off()
                
                }else {
                    stop("needs update. choose single-panel multi-generation plot.")
                }
            }
        }
    }
}
```

# plotting function for trajectory (multi psi per n)
```{R}
plot_summary_multi_by_psi_ticks <- function(summary_stat_df,
                                            out_subfolder = "summary_multi_by_psi_ticks",
                                            regimes = NULL) {
  if (!dir.exists(file.path(base_plot_folder, out_subfolder))) {
    dir.create(file.path(base_plot_folder, out_subfolder), recursive = TRUE)
  }

  for (reg_lab in regimes) {
    df_reg <- subset(summary_stat_df, reg == reg_lab)
    if (nrow(df_reg) == 0) next

    out_dir <- file.path(base_plot_folder, out_subfolder, paste0("model_", reg_lab))
    if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

    shift_keys <- paste0("shift=", plot_shift_sizes)

    all_vals <- plot_psi
    mean_cols <- hcl.colors(length(all_vals), hcl_color_palette)

    for (sk in shift_keys) {
      shift_val <- as.numeric(sub("shift=", "", sk))
      df_shift <- subset(df_reg, shift_size == shift_val)
      if (nrow(df_shift) == 0) next

      ## ---- Compute shared y-limits across all n & all_vals for this (reg, shift) ----
      y_min <- Inf; y_max <- -Inf
      for (n_val in plot_n) {
        df_n <- subset(df_shift, n == n_val)
        if (nrow(df_n) == 0) next
        for (val in all_vals) {
          df_p <- subset(df_n, psi  == val & tick %in% tick_seq)
          
          if (nrow(df_p) == 0) next
          s <- .compute_series(df_p, tick_seq)
          y_all <- c(unlist(s$reps, use.names = FALSE), s$mean)
          y_all <- y_all[is.finite(y_all)]
          if (length(y_all)) {
            y_min <- min(y_min, y_all)
            y_max <- max(y_max, y_all)
          }
        }
      }
      if (!is.finite(y_min) || !is.finite(y_max) || y_min == y_max) { y_min <- 0; y_max <- 1 }

      ## ---- Open ONE PDF with multiple panels (one per n) ----
      n_panels <- length(plot_n)
      nrow_panel <- ceiling(sqrt(n_panels))
      ncol_panel <- ceiling(n_panels / nrow_panel)

      title_suffix <- paste0("shift_size = ", shift_val)
      out_name <- paste0("multiN_", gsub("[ =]", "", title_suffix), ".pdf")
      pdf(file.path(out_dir, out_name), width = 4.5 * ncol_panel, height = 3.8 * nrow_panel)
      op <- par(mfrow = c(nrow_panel, ncol_panel),
                mar = c(4, 4, 2.6, 1) + 0.1, oma = c(0, 0, 2.8, 0))

      ## ---- Draw each subpanel for each n ----
      for (n_val in plot_n) {
        df_n <- subset(df_shift, n == n_val)
        plot(NA, xlim = range(tick_seq), ylim = c(y_min, y_max),
             xlab = "Tick", ylab = "Distance to Optimum",
             main = paste0("n = ", n_val, " | ", title_suffix, " | model = ", reg_lab),
             xaxt = "n")
        axis(1, at = tick_seq)

        for (i in seq_along(all_vals)) {
          val <- all_vals[i]
          mean_col <- mean_cols[i]
          df_p <- subset(df_n, psi  == val & tick %in% tick_seq)
          
          if (nrow(df_p) == 0) next

          s <- .compute_series(df_p, tick_seq)

          if (plot_reps && length(s$reps)) {
            rep_col <- adjustcolor(mean_col, alpha.f = 0.35)
            for (r in seq_along(s$reps)) {
              lines(tick_seq, s$reps[[r]], col = rep_col, lwd = 1)
              points(tick_seq, s$reps[[r]], pch = 16, cex = 0.5, col = rep_col)
            }
          }
          lines(tick_seq, s$mean, col = mean_col, lwd = 2)
          points(tick_seq, s$mean, pch = 16, cex = 0.9, col = mean_col)
        }

        ## ---- Add non-social exponential decay for this panel ----
        # Assumes you provide: plot_nonsocial_decay(shift_size, n)
        # plot_nonsocial_decay(reg_lab, shift_val, n_val)

        ## ---- Optional: legend per panel (values of psi/psi) ----
        legend_vals <- paste0("psi=", all_vals)
        legend("topright", inset = 0.02,
               legend = legend_vals, col = mean_cols,
               lty = 1, lwd = 1, pch = 16, pt.cex = 0.5, bty = "n", cex = 0.85)
      }

      mtext(paste0("Trajectory over ticks | model = ", reg_lab, " | ", title_suffix),
            outer = TRUE, cex = 1.0, line = 0.6)
      par(op)
      dev.off()
    }
  }
}


```

```{r}
regs   <- c("ext","ave","fit")
ns     <- c(2,8, 20, 50)
shifts <- c(40, 80, 120)
d <- list(ext = 0)
l <- list(
    list( # ext
        list( # n=2
            list(  #shift
                0.087, 40.575, 0.041
                )
            )
        ),
    )

plot_nonsocial_decay <- function(reg_lab, shift_size, n_val){
    level1_index <- match(reg_lab, regs)
    level2_index <- match(n_val, ns)
    level3_index <- match(shift_size, shifts)

    c0 <- l[[level1_index]][[level2_index]][[level3_index]][[1]]
    c1 <- l[[level1_index]][[level2_index]][[level3_index]][[2]]
    k <- l[[level1_index]][[level2_index]][[level3_index]][[3]]

    t0 <- 9999

    # x-range to draw across (use your plot's ticks)
    xx <- tick_seq                           # or xx <- seq(min_x, max_x, by = 1)
    yy <- c1 * exp(-k * (xx - t0)) + c0
    yy[xx < t0] <- NA                        # (optional) don't draw before t0

    lines(xx, yy, lwd = 2, lty = 2)          # add to existing plot
}
```

# plotting function for trajectory (multi n per psi)
```{r}
plot_summary_multi_by_psi_ticks <- function(summary_stat_df,
                                            out_subfolder = "summary_multi_by_psi_ticks",
                                            regimes = NULL) {
  if (!dir.exists(file.path(base_plot_folder, out_subfolder))) {
    dir.create(file.path(base_plot_folder, out_subfolder), recursive = TRUE)
  }

  for (reg_lab in regimes) {
    df_reg <- subset(summary_stat_df, reg == reg_lab)
    if (nrow(df_reg) == 0) next

    out_dir <- file.path(base_plot_folder, out_subfolder, paste0("model_", reg_lab))
    if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

    shift_keys <- c(paste0("shift=", plot_shift_sizes))

    # Always loop over psi values (one file per psi)
    all_psis <- sort(unique(na.omit(df_reg$psi)))
    # if you want to force a pre-defined set: all_psis <- plot_psi

    for (sk in shift_keys) {
      shift_val <- as.numeric(sub("shift=", "", sk))
      df_shift <- subset(df_reg, shift_size == shift_val)
      if (nrow(df_shift) == 0) next

      for (psi_val in all_psis) {
        df_psi <- subset(df_shift, psi == psi_val & tick %in% tick_seq)
        if (nrow(df_psi) == 0) next

        # ---- Y-limits across all n for this (reg, shift, psi) ----
        y_min <- Inf; y_max <- -Inf
        for (n_val in plot_n) {
          df_n <- subset(df_psi, n == n_val)
          if (nrow(df_n) == 0) next
          s <- .compute_series(df_n, tick_seq)  # should compute on column 'opt_z_dis'
          y_all <- c(unlist(s$reps, use.names = FALSE), s$mean)
          y_all <- y_all[is.finite(y_all)]
          if (length(y_all)) {
            y_min <- min(y_min, y_all)
            y_max <- max(y_max, y_all)
          }
        }
        if (!is.finite(y_min) || !is.finite(y_max) || y_min == y_max) {
          y_min <- 0; y_max <- 1
        }

        title_suffix <- paste0("shift_size = ", shift_val)
        out_name <- paste0("psi_", gsub("[.]", "p", as.character(psi_val)),
                           "_", gsub("[ =]", "", title_suffix), ".pdf")
        pdf(file.path(out_dir, out_name), width = 9, height = 7)

        mean_cols <- hcl.colors(length(plot_n), hcl_color_palette)

        plot(NA, xlim = range(tick_seq), ylim = c(y_min, y_max),
             xlab = "Tick", ylab = "Distance to Optimum (opt_z_dis)",
             main = paste0("Trajectory over ticks | model = ", reg_lab,
                           " | psi = ", psi_val, " | ", title_suffix),
             xaxt = "n")
        axis(1, at = tick_seq)

        # ---- Overlay each n in its own color ----
        for (i in seq_along(plot_n)) {
          n_val <- plot_n[i]
          mean_col <- mean_cols[i]

          df_n <- subset(df_psi, n == n_val)
          if (nrow(df_n) == 0) next

          s <- .compute_series(df_n, tick_seq)  # uses opt_z_dis inside

          if (plot_reps && length(s$reps)) {
            rep_col <- adjustcolor(mean_col, alpha.f = 0.35)
            for (r in seq_along(s$reps)) {
              lines(tick_seq, s$reps[[r]], col = rep_col, lwd = 1)
              points(tick_seq, s$reps[[r]], pch = 16, cex = 0.5, col = rep_col)
            }
          }

          lines(tick_seq, s$mean, col = mean_col, lwd = 2)
          points(tick_seq, s$mean, pch = 16, cex = 0.9, col = mean_col)

          # Optional: exponential-decay fit (skip tick 9999)
          if (plot_exp_fit && is.finite(min(s$mean, na.rm = TRUE)) && is.finite(max(s$mean, na.rm = TRUE))) {
            present <- is.finite(s$mean) & (tick_seq != 9999)
            x_fit <- tick_seq[present]; y_fit <- s$mean[present]
            if (length(x_fit) >= 5 && diff(range(y_fit)) > 0) {
              fit <- .fit_exp_decay(x_fit, y_fit)
              if (isTRUE(fit$success)) {
                lines(fit$x_fit, fit$y_fit, col = "black", lwd = 2, lty = 2)
              }
            }
          }
        }

        # Legend for n values
        leg_vals <- paste0("n=", plot_n)
        if (plot_exp_fit) {
          legend("topright", inset = 0.02,
                 legend = c(leg_vals, "Exp. decay fit"),
                 col    = c(mean_cols, "black"),
                 lty    = c(rep(1, length(leg_vals)), 1),
                 lwd    = c(rep(1, length(leg_vals)), 2),
                 pch    = c(rep(16, length(leg_vals)), 16),
                 pt.cex = c(rep(0.5, length(leg_vals)), 0.9),
                 bty = "n", cex = 0.85)
        } else {
          legend("topright", inset = 0.02,
                 legend = leg_vals,
                 col    = mean_cols,
                 lty    = 1, lwd = 1, pch = 16, pt.cex = 0.5,
                 bty = "n", cex = 0.85)
        }

        dev.off()
      } # psi
    } # shift
  } # reg
}

```




# plotting function for phenotype distribution
```{r}
plot_phenotype_multi <- function(phenotype_df,
                                       out_subfolder = "phenotype_multi_by_psi_genbins",
                                       gen_seq = 10000:10005,
                                       num_bins = num_bins,
                                       bin_width = bin_width,
                                       half_span = half_span,
                                       regimes = regimes,
                                       single_panel = TRUE,
                                       pre_selection_gen = 9999,
                                       include_pre_selection = FALSE) {   # <--- added
    include_pre_selection <- include_pre_selection & !(pre_selection_gen %in% gen_seq)                                   
    # Loop over regimes
    for (reg_lab in regimes) {
        df_reg <- subset(phenotype_df, reg == reg_lab)
        if (nrow(df_reg) == 0) next

        # Separate subfolder per regime
        out_dir <- file.path(base_plot_folder, out_subfolder, paste0("model_", reg_lab))
        if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

        for (n_val in plot_n) {
            df_n <- subset(df_reg, n == n_val)
            if (nrow(df_n) == 0) next

            shift_keys <- paste0("shift=", plot_shift_sizes)
            all_vals <- plot_psi

            for (sk in shift_keys) {
                df_group <- subset(df_n, shift_size == as.numeric(sub("shift=", "", sk)))
                
                if (nrow(df_group) == 0) next

                # Common y-limit and x-range across all psi & gens
                max_y <- 0
                x_min <- Inf; x_max <- -Inf
                for (val in all_vals) {
                    df_p <- subset(df_group, psi == val)
                    
                    
                    if (nrow(df_p) == 0) next
                    for (g in gen_seq) {
                        df_pg <- subset(df_p, generation == g)
                        center <- .compute_center(df_pg)
                        if (!is.finite(center)) next
                        breaks_g <- seq(center - half_span, center + half_span, by = bin_width)
                        avg_counts <- .avg_hist_curve_with_breaks(df_pg, breaks_g, num_bins)
                        max_y <- max(max_y, avg_counts, na.rm = TRUE)
                        x_min <- min(x_min, min(breaks_g), na.rm = TRUE)
                        x_max <- max(x_max, max(breaks_g), na.rm = TRUE)
                    }

                    if (include_pre_selection) {
                        df_pre <- subset(df_p, generation == pre_selection_gen)
                        center <- .compute_center(df_pre)
                        if (is.finite(center)) {
                            breaks_pre <- seq(center - half_span, center + half_span, by = bin_width)
                            avg_counts_pre <- .avg_hist_curve_with_breaks(df_pre, breaks_pre, num_bins)
                            max_y <- max(max_y, avg_counts_pre, na.rm = TRUE)
                            x_min <- min(x_min, min(breaks_pre), na.rm = TRUE)
                            x_max <- max(x_max, max(breaks_pre), na.rm = TRUE)
                        }
                    }
                }
                if (!is.finite(max_y) || max_y <= 0) max_y <- 1
                if (!is.finite(x_min) || !is.finite(x_max) || x_min >= x_max) {
                    x_min <- -half_span; x_max <- half_span
                }

                if (single_panel & length(gen_seq) == 1) {
                    # Single panel
                    png_w <- 9; png_h <- 7
                    title_suffix <- paste0("shift_size = ", as.numeric(sub("shift=", "", sk)))
                    out_name <- paste0("n_", n_val, "_", gsub("[ =]", "", title_suffix), ".pdf")
                    pdf(file.path(out_dir, out_name), width = png_w, height = png_h)
                    op <- par(mfrow = c(1, 1), mar = c(4, 4, 3, 1) + 0.1, oma = c(0, 0, 3.5, 0))

                    plot(NULL,
                        xlim = c(x_min, x_max), ylim = c(0, max_y),
                        xlab = "Phenotype Value", ylab = "Proportion",
                        main = paste0("Phenotype distributions | model = ", reg_lab,
                            " | n = ", n_val, " | ", title_suffix))

                    # curve(dnorm(x, mean = as.numeric(sub("shift=", "", sk)), sd = sqrt(2000)),
                    #     add = TRUE, col = "black", lty = 2, lwd = 2)
                    curve(dnorm(x, mean = 0, sd = sqrt(2000)),
                        add = TRUE, col = "black", lty = 2, lwd = 2)

                    val_col <- hcl.colors(length(all_vals), palette = hcl_color_palette)
                    names(val_col) <- as.character(all_vals)
                    for (val in all_vals) {
                        df_p <- subset(df_group, psi == val)
                        
                        if (nrow(df_p) == 0) next

                        g= gen_seq[1]  # only one generation
                        df_pg <- subset(df_p, generation == g)
                        center <- .compute_center(df_pg)
                        if (!is.finite(center)) next
                        breaks_g <- seq(center - half_span, center + half_span, by = bin_width)
                        mids_g   <- 0.5 * (breaks_g[-length(breaks_g)] + breaks_g[-1])
                        avg_counts <- .avg_hist_curve_with_breaks(df_pg, breaks_g, num_bins)
                        if (all(is.na(avg_counts))) next
                        lines(mids_g, avg_counts, col = val_col[as.character(val)], lwd = 2)

                        if (include_pre_selection) {
                            df_pre <- subset(df_p, generation == pre_selection_gen)
                            center <- .compute_center(df_pre)
                            if (is.finite(center)) {
                                breaks_pre <- seq(center - half_span, center + half_span, by = bin_width)
                                mids_pre   <- 0.5 * (breaks_pre[-length(breaks_pre)] + breaks_pre[-1])
                                avg_counts_pre <- .avg_hist_curve_with_breaks(df_pre, breaks_pre, num_bins)
                                if (!all(is.na(avg_counts_pre))) {
                                    lines(mids_pre, avg_counts_pre,
                                        col = adjustcolor(val_col[as.character(val)], alpha.f = 0.5),
                                        lwd = 2, lty = 1)
                                }
                            }
                        }
                    }

                    legend_text = paste0("psi=", all_vals)
                    legend_text = if (include_pre_selection) {
                        c(legend_text, "Fitness Func", "Pre-selection")
                    } else {
                        c(legend_text, "Fitness Func")
                    }
                    col_lab <- if (include_pre_selection) {
                        c(val_col[as.character(all_vals)], "black", adjustcolor("black", alpha.f = 0.5))
                    } else {
                        c(val_col[as.character(all_vals)], "black")
                    }
                    lty = if (include_pre_selection) {
                        c(rep(1, length(all_vals)), 2, 1)
                    } else {
                        c(rep(1, length(all_vals)), 2)
                    }
                    legend("topright",
                            legend = legend_text,
                            col = col_lab,
                            lty = lty, lwd = 2, cex = 0.8, bg = "white")
                    par(op)
                    dev.off()
                }else if (single_panel & length(gen_seq) > 1)
                {
                    # Single panel
                    gap <- gen_seq[3] - gen_seq[2]
                    png_w <- 9; png_h <- 7
                    title_suffix <- paste0("shift_size = ", as.numeric(sub("shift=", "", sk)))
                    if (include_pre_selection) {
                        out_name <- paste0("n_", n_val, "_", gsub("[ =]", "", title_suffix), "by_", gap, "_pre.pdf")
                    } else{
                        out_name <- paste0("n_", n_val, "_", gsub("[ =]", "", title_suffix), "by_", gap, ".pdf")
                    }
                    pdf(file.path(out_dir, out_name), width = png_w, height = png_h)
                    op <- par(mfrow = c(1, 1), mar = c(4, 4, 3, 1) + 0.1, oma = c(0, 0, 3.5, 0))

                    plot(NULL,
                        xlim = c(x_min, x_max), ylim = c(0, max_y),
                        xlab = "Phenotype Value", ylab = "Proportion",
                        main = paste0("Phenotype distributions | model = ", reg_lab,
                            " | n = ", n_val, " | ", title_suffix))

                    curve(dnorm(x, mean = as.numeric(sub("shift=", "", sk)), sd = sqrt(2000)),
                        add = TRUE, col = "black", lty = 2, lwd = 2)

                    val_col <- hcl.colors(length(all_vals), palette = hcl_color_palette)
                    names(val_col) <- as.character(all_vals)
                    alphas <- seq(0.3, 1.0, length.out = length(gen_seq))
                    names(alphas) <- as.character(gen_seq)
                    
                    for (val in all_vals) {
                        df_p <- subset(df_group, psi == val)
                        if (nrow(df_p) == 0) next

                        base_col <- val_col[as.character(val)]

                        for (g in gen_seq) {
                            df_pg <- subset(df_p, generation == g)
                            center <- .compute_center(df_pg)
                            if (!is.finite(center)) next

                            breaks_g <- seq(center - half_span, center + half_span, by = bin_width)
                            mids_g   <- 0.5 * (breaks_g[-length(breaks_g)] + breaks_g[-1])
                            avg_counts <- .avg_hist_curve_with_breaks(df_pg, breaks_g, num_bins)
                            if (all(is.na(avg_counts))) next

                            lines(mids_g, avg_counts,
                                col = adjustcolor(base_col, alpha.f = alphas[as.character(g)]),
                                lwd = 2)
                        }
         
                        if (include_pre_selection) {
                            df_pre <- subset(df_p, generation == pre_selection_gen)
                            center <- .compute_center(df_pre)
                            if (is.finite(center)) {
                                breaks_pre <- seq(center - half_span, center + half_span, by = bin_width)
                                mids_pre   <- 0.5 * (breaks_pre[-length(breaks_pre)] + breaks_pre[-1])
                                avg_counts_pre <- .avg_hist_curve_with_breaks(df_pre, breaks_pre, num_bins)
                                if (!all(is.na(avg_counts_pre))) {
                                    lines(mids_pre, avg_counts_pre,
                                        col = adjustcolor(val_col[as.character(val)]),
                                        lwd = 2, lty = 5)
                                }
                            }
                        }
                    }

                    legend_text = paste0("psi=", all_vals)
                    
                    legend_text = if (include_pre_selection) {
                        c(legend_text, "Fitness Func", "Pre-selection")
                    } else {
                        c(legend_text, "Fitness Func")
                    }
                    col_lab <- if (include_pre_selection) {
                        c(val_col[as.character(all_vals)], "black", "black")
                    } else {
                        c(val_col[as.character(all_vals)], "black")
                    }
                    lty = if (include_pre_selection) {
                        c(rep(1, length(all_vals)), 2, 5)
                    } else {
                        c(rep(1, length(all_vals)), 2)
                    }
                    legend("topright",
                            legend = legend_text,
                            col = col_lab,
                            lty = lty, lwd = 2, cex = 0.8, bg = "white")
                    early <- head(gen_seq, 1); late <- tail(gen_seq, 1)
                    legend("topleft",
                            legend = c(paste0("gen ", early), paste0("gen ", late), "later = darker"),
                            col = c(adjustcolor("black", alpha.f = alphas[as.character(early)]),
                                    adjustcolor("black", alpha.f = alphas[as.character(late)]),
                                    NA),
                            lty = c(1,1,NA), lwd = c(2,2,NA), cex = 0.8, bg = "white", bty = "o")
                    
                    par(op)
                    dev.off()
                
                }else {
                    stop("needs update. choose single-panel multi-generation plot.")
                }
            }
        }
    }
}
```

# plot all model in one figure
```{r}
plot_distribution_multi_model <- function(
    data_df,
    out_subfolder = "test",
    gen_seq = 10000:10005,
    num_bins = num_bins,
    bin_width = bin_width,
    half_span = half_span,
    regimes = c("ave","fit","ext","inv"),
    include_pre_selection = FALSE,
    pre_selection_gen = 9999,
    # value sets
    psi_vals  = plot_psi,
    custom_vals = NULL,   # list, e.g. list(ave = c(0.1,0.3), fit = c(0.2,0.4))
    value_label = c("Genotype","Phenotype")  # NEW: controls figure labels
) {
    # --- normalize label (proper case for display, lower for filenames if needed) ---
    value_label_lower <- tolower(value_label)

    include_pre_selection <- include_pre_selection & !(pre_selection_gen %in% gen_seq)

    # ---- util: per-reg value set & variable type label ----
    .vals_for_reg <- function(reg_lab) {
        if (!is.null(custom_vals) && !is.null(custom_vals[[reg_lab]])) {
            return(list(vals = custom_vals[[reg_lab]],
                        vtype ="psi"))
        }
        list(vals = psi_vals,  vtype = "psi")
    }

    # ---- reorder: ensure 'inv' is NOT the 2nd panel ----
    if ("inv" %in% regimes && length(regimes) >= 2) {
        inv_idx <- which(regimes == "inv")[1]
        if (inv_idx == 2) {
            tmp <- regimes[1]; regimes[1] <- regimes[2]; regimes[2] <- tmp
        }
    }

    # ---------- compute shared axes across regs for (n, shift) ----------
    .compute_common_limits <- function(n_val, shift_size_target) {
        max_y <- 0; x_min <- Inf; x_max <- -Inf
        for (reg_lab in regimes) {
            spec <- .vals_for_reg(reg_lab)
            all_vals <- spec$vals
            for (val in all_vals) {
                df_reg <- subset(data_df,
                                 reg == reg_lab & n == n_val & shift_size == shift_size_target &
                                  (spec$vtype == "psi"  & psi  == val))
                if (nrow(df_reg) == 0) next

                for (g in gen_seq) {
                    df_pg <- subset(df_reg, generation == g)
                    center <- .compute_center(df_pg)
                    if (!is.finite(center)) next
                    breaks_g <- seq(center - half_span, center + half_span, by = bin_width)
                    avg_counts <- .avg_hist_curve_with_breaks(df_pg, breaks_g, num_bins)
                    max_y <- max(max_y, avg_counts, na.rm = TRUE)
                    x_min <- min(x_min, min(breaks_g), na.rm = TRUE)
                    x_max <- max(x_max, max(breaks_g), na.rm = TRUE)
                }

                if (include_pre_selection) {
                    df_pre <- subset(df_reg, generation == pre_selection_gen)
                    center <- .compute_center(df_pre)
                    if (is.finite(center)) {
                        breaks_pre <- seq(center - half_span, center + half_span, by = bin_width)
                        avg_counts_pre <- .avg_hist_curve_with_breaks(df_pre, breaks_pre, num_bins)
                        max_y <- max(max_y, avg_counts_pre, na.rm = TRUE)
                        x_min <- min(x_min, min(breaks_pre), na.rm = TRUE)
                        x_max <- max(x_max, max(breaks_pre), na.rm = TRUE)
                    }
                }
            }
        }
        if (!is.finite(max_y) || max_y <= 0) max_y <- 1
        if (!is.finite(x_min) || !is.finite(x_max) || x_min >= x_max) {
            x_min <- -half_span; x_max <- half_span
        }
        list(xlim = c(x_min, x_max), ylim = c(0, max_y))
    }

    # ---------- draw one panel for a given reg ----------
    .draw_panel_for_reg <- function(reg_lab, n_val, shift_size_target, xlim, ylim,
                                    draw_param_legend = FALSE, draw_gen_legend = FALSE) {
        spec <- .vals_for_reg(reg_lab)
        all_vals <- spec$vals
        vtype    <- spec$vtype  # "psi"

        df_reg <- subset(data_df, reg == reg_lab & n == n_val & shift_size == shift_size_target)
        plot(NULL, xlim = xlim, ylim = ylim,
             xlab = paste(value_label, "Value"),  # CHANGED
             ylab = "Proportion",
             main = paste0("Model = ", reg_lab))

        curve(dnorm(x, mean = shift_size_target, sd = sqrt(2000)),
              add = TRUE, col = "black", lty = 2, lwd = 2)

        val_col <- hcl.colors(length(all_vals), palette = hcl_color_palette)
        names(val_col) <- as.character(all_vals)
        alphas <- seq(0.3, 1.0, length.out = length(gen_seq))
        names(alphas) <- as.character(gen_seq)

        for (val in all_vals) {
            df_p <- subset(df_reg, vtype == "psi" & psi == val)
            if (nrow(df_p) == 0) next
            base_col <- val_col[as.character(val)]

            for (g in gen_seq) {
                df_pg <- subset(df_p, generation == g)
                center <- .compute_center(df_pg)
                if (!is.finite(center)) next
                breaks_g <- seq(center - half_span, center + half_span, by = bin_width)
                mids_g   <- 0.5 * (breaks_g[-length(breaks_g)] + breaks_g[-1])
                avg_counts <- .avg_hist_curve_with_breaks(df_pg, breaks_g, num_bins)
                if (all(is.na(avg_counts))) next
                lines(mids_g, avg_counts,
                      col = adjustcolor(base_col, alpha.f = alphas[as.character(g)]), lwd = 2)
            }

            if (include_pre_selection) {
                df_pre <- subset(df_p, generation == pre_selection_gen)
                center <- .compute_center(df_pre)
                if (is.finite(center)) {
                    breaks_pre <- seq(center - half_span, center + half_span, by = bin_width)
                    mids_pre   <- 0.5 * (breaks_pre[-length(breaks_pre)] + breaks_pre[-1])
                    avg_counts_pre <- .avg_hist_curve_with_breaks(df_pre, breaks_pre, num_bins)
                    if (!all(is.na(avg_counts_pre))) {
                        lines(mids_pre, avg_counts_pre, col = adjustcolor(base_col), lwd = 2, lty = 5)
                    }
                }
            }
        }

        # legends
        if (draw_param_legend) {
            legend_labels <- paste0("psi=", all_vals)
            legend("topright",
                   legend = legend_labels,
                   col = val_col[as.character(all_vals)],
                   lty = rep(1, length(all_vals)),
                   lwd = 2, cex = 0.8, bg = "white")
        }
        if (draw_gen_legend) {
            early <- head(gen_seq, 1); late <- tail(gen_seq, 1)
            legend_text <- c(paste0("gen ", early), paste0("gen ", late), "later = darker", "Fitness Func")
            col_text <- c(adjustcolor("black", alpha.f = alphas[as.character(early)]),
                          adjustcolor("black", alpha.f = alphas[as.character(late)]),
                          NA,
                          "black")
            lty_text <- c(1, 1, NA, 2)
            lwd_text <- c(2, 2, NA, 2)

            if (include_pre_selection) {
                legend_text <- c(legend_text, "Pre-selection")
                col_text <- c(col_text, "black")
                lty_text <- c(lty_text, 5)
                lwd_text <- c(lwd_text, 2)
            }
            legend("topleft",
                   legend = legend_text,
                   col = col_text,
                   lty = lty_text, lwd = lwd_text, cex = 0.8, bg = "white", bty = "o")
        }
    }

    # ---------- main driver ----------
    out_dir <- file.path(base_plot_folder, out_subfolder)
    if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

    gap <- gen_seq[3] - gen_seq[2]
    for (n_val in plot_n) {
        for (shift_size_target in plot_shift_sizes) {
            lims <- .compute_common_limits(n_val, shift_size_target)
            xlim <- lims$xlim; ylim <- lims$ylim

            # layout: 22 if 4 regs; else compact grid
            nreg <- length(regimes)
            nrow_layout <- if (nreg <= 3) 1 else 2
            ncol_layout <- if (nreg <= 3) nreg else 2

            # wider panels (65 per panel)
            png_w <- 6 * ncol_layout
            png_h <- 5 * nrow_layout

            if (include_pre_selection) {
                out_name <- paste0("n_", n_val, "_shift_", shift_size_target, "_by_", gap, "_", value_label_lower, "_", min(gen_seq), ":", max(gen_seq),"_pre.pdf")
            } else{
                out_name <- paste0("n_", n_val, "_shift_", shift_size_target, "_by_", gap, "_", value_label_lower, "_", min(gen_seq), ":", max(gen_seq),".pdf")
            }
            pdf(file.path(out_dir, out_name), width = png_w, height = png_h)
            op <- par(mfrow = c(nrow_layout, ncol_layout),
                      mar = c(4, 4, 3, 1) + 0.1,
                      oma = c(0, 0, 3, 0))

            for (i in seq_along(regimes)) {
                reg_lab <- regimes[i]
                draw_gen_legend   <- (i == 1)         # top-left
                draw_param_legend <- (i == ncol_layout)         # top-right (always)
                .draw_panel_for_reg(reg_lab, n_val, shift_size_target, xlim, ylim,
                                    draw_param_legend = draw_param_legend,
                                    draw_gen_legend   = draw_gen_legend)
            }

            mtext(paste0(value_label, " distributions | n = ", n_val,     # CHANGED
                         " | shift_size = ", shift_size_target,
                         " by ", gap,
                         " | models: ", paste(regimes, collapse = ", ")),
                  outer = TRUE, cex = 1.1, line = 1)

            par(op); dev.off()
        }
    }
}

```

```{R}

plot_psis_mean_by_psi_ticks <- function(summary_stat_df,
                                        out_subfolder = "psis_mean_by_psi_ticks",
                                        regimes = NULL) {
  if (!dir.exists(file.path(base_plot_folder, out_subfolder))) {
    dir.create(file.path(base_plot_folder, out_subfolder), recursive = TRUE)
  }

  for (reg_lab in regimes) {
    df_reg <- subset(summary_stat_df, reg == reg_lab)
    if (nrow(df_reg) == 0) next

    out_dir <- file.path(base_plot_folder, out_subfolder, paste0("model_", reg_lab))
    if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

    shift_keys <- paste0("shift=", plot_shift_sizes)
    all_psis   <- sort(unique(na.omit(df_reg$psi)))  # or use: all_psis <- plot_psi

    for (sk in shift_keys) {
      shift_val <- as.numeric(sub("shift=", "", sk))
      df_shift <- subset(df_reg, shift_size == shift_val)
      if (nrow(df_shift) == 0) next

      for (psi_val in all_psis) {
        df_psi <- subset(df_shift, psi == psi_val & tick %in% tick_seq)
        if (nrow(df_psi) == 0) next

        ## ---- Compute y-limits across all n using psis_mean ----
        y_min <- Inf; y_max <- -Inf
        for (n_val in plot_n) {
          df_n <- subset(df_psi, n == n_val)
          if (nrow(df_n) == 0) next
          # align to tick_seq by rep
          reps <- sort(unique(df_n$rep))
          if (length(reps) == 0) next
          for (rp in reps) {
            d <- subset(df_n, rep == rp)
            yy <- rep(NA_real_, length(tick_seq))
            m  <- match(tick_seq, d$tick)
            ok <- is.finite(m)
            yy[ok] <- d$psis_mean[m[ok]]
            vals <- yy[is.finite(yy)]
            if (length(vals)) {
              y_min <- min(y_min, vals)
              y_max <- max(y_max, vals)
            }
          }
          # across-rep mean
          # build a matrix reps  ticks
          y_mat <- sapply(reps, function(rp) {
            d <- subset(df_n, rep == rp)
            v <- rep(NA_real_, length(tick_seq))
            m <- match(tick_seq, d$tick)
            ok <- is.finite(m)
            v[ok] <- d$psis_mean[m[ok]]
            v
          })
          if (!is.null(dim(y_mat))) {
            mean_vec <- rowMeans(y_mat, na.rm = TRUE)
            vals <- mean_vec[is.finite(mean_vec)]
            if (length(vals)) {
              y_min <- min(y_min, vals, y_min)
              y_max <- max(y_max, vals, y_max)
            }
          }
        }
        if (!is.finite(y_min) || !is.finite(y_max) || y_min == y_max) {
          y_min <- 0; y_max <- 1
        }

        ## ---- Open PDF & base frame ----
        title_suffix <- paste0("shift_size = ", shift_val)
        out_name <- paste0("psi_", gsub("[.]", "p", as.character(psi_val)),
                           "_", gsub("[ =]", "", title_suffix), ".pdf")
        pdf(file.path(out_dir, out_name), width = 9, height = 7)

        mean_cols <- hcl.colors(length(plot_n), hcl_color_palette)

        plot(NA, xlim = range(tick_seq), ylim = c(y_min, y_max),
             xlab = "Tick", ylab = "psis_mean",
             main = paste0("psis_mean over time | model = ", reg_lab,
                           " | psi = ", psi_val, " | ", title_suffix),
             xaxt = "n")
        axis(1, at = tick_seq)

        ## ---- Overlay each n ----
        for (i in seq_along(plot_n)) {
          n_val   <- plot_n[i]
          mean_col <- mean_cols[i]

          df_n <- subset(df_psi, n == n_val)
          if (nrow(df_n) == 0) next

          reps <- sort(unique(df_n$rep))
          if (length(reps) == 0) next

          # Build matrix (rows = ticks, cols = reps)
          y_mat <- sapply(reps, function(rp) {
            d <- subset(df_n, rep == rp)
            v <- rep(NA_real_, length(tick_seq))
            m <- match(tick_seq, d$tick)
            ok <- is.finite(m)
            v[ok] <- d$psis_mean[m[ok]]
            v
          })

          # Draw replicate series
          if (plot_reps && !is.null(dim(y_mat))) {
            rep_col <- adjustcolor(mean_col, alpha.f = 0.35)
            for (j in seq_along(reps)) {
              yy <- y_mat[, j]
              if (all(!is.finite(yy))) next
              lines(tick_seq, yy, col = rep_col, lwd = 1)
              points(tick_seq, yy, pch = 16, cex = 0.5, col = rep_col)
            }
          }

          # Across-rep mean
          if (!is.null(dim(y_mat))) {
            mean_vec <- rowMeans(y_mat, na.rm = TRUE)
            if (any(is.finite(mean_vec))) {
              lines(tick_seq, mean_vec, col = mean_col, lwd = 2)
              points(tick_seq, mean_vec, pch = 16, cex = 0.9, col = mean_col)

              # Optional: exponential-decay fit (skip tick 9999)
              if (plot_exp_fit) {
                present <- is.finite(mean_vec) & (tick_seq != 9999)
                x_fit <- tick_seq[present]; y_fit <- mean_vec[present]
                if (length(x_fit) >= 5 && diff(range(y_fit)) > 0) {
                  fit <- .fit_exp_decay(x_fit, y_fit)
                  if (isTRUE(fit$success)) {
                    lines(fit$x_fit, fit$y_fit, col = "black", lwd = 2, lty = 2)
                  }
                }
              }
            }
          }
        }

        # Legend: one entry per n (+ optional fit)
        leg_vals <- paste0("n=", plot_n)
        if (plot_exp_fit) {
          legend("bottomright", inset = 0.02,
                 legend = c(leg_vals, "Exp. decay fit"),
                 col    = c(mean_cols, "black"),
                 lty    = c(rep(1, length(leg_vals)), 1),
                 lwd    = c(rep(1, length(leg_vals)), 2),
                 pch    = c(rep(16, length(leg_vals)), 16),
                 pt.cex = c(rep(0.5, length(leg_vals)), 0.9),
                 bty = "n", cex = 0.85)
        } else {
          legend("bottomright", inset = 0.02,
                 legend = leg_vals,
                 col    = mean_cols,
                 lty    = 1, lwd = 1, pch = 16, pt.cex = 0.5,
                 bty = "n", cex = 0.85)
        }

        dev.off()
      } # psi
    } # shift
  } # reg
}
```

## plot sociality distribution
```{r}
plot_psi_histograms_by_gen <- function(df,
                                       target_gen,
                                       regs = c("ext","ave","fit"),
                                       plot_n = NULL,
                                       pool_reps = TRUE,
                                       nbins = 60,
                                       breaks = NULL,          # optional numeric vector of breaks to force
                                       value_col = "value",    # column holding per-individual psi values
                                       out_subfolder = "psi_hists_gen") {
  # ---- helpers ----
  .gen_key <- function(d) {
    if ("tick" %in% names(d)) return("tick")
    if ("generation" %in% names(d)) return("generation")
    names(d)[1]
  }
  gen_col <- .gen_key(df)

  # Keep only psi rows (if df includes psin long format)
  if ("variable" %in% names(df)) {
    df <- subset(df, variable == "psi")
  }
  if (!value_col %in% names(df)) stop("value_col '", value_col, "' not found in df")

  # Choose n list if not specified
  if (is.null(plot_n)) {
    plot_n <- sort(unique(df$n))
  }

  # Output dirs by regime
  base_dir <- file.path(base_plot_folder, out_subfolder)
  if (!dir.exists(base_dir)) dir.create(base_dir, recursive = TRUE)

  # iterate regimes
  for (reg_lab in regs) {
    d_reg <- subset(df, reg == reg_lab & get(gen_col) == target_gen)
    if (nrow(d_reg) == 0) next

    # Build common breaks across ALL n in this (reg, gen), unless user supplies 'breaks'
    brks <- breaks
    if (is.null(brks)) {
      # range from all psi values available for this reg/gen
      vals_all <- d_reg[[value_col]]
      vals_all <- vals_all[is.finite(vals_all)]
      if (!length(vals_all)) next
      rng <- range(vals_all)
      # If degenerate range, widen slightly
      if (rng[1] == rng[2]) rng <- rng + c(-0.5, 0.5)
      brks <- seq(rng[1], rng[2], length.out = nbins + 1)
    }

    # Prepare PDF: one panel per n
    out_dir <- file.path(base_dir, paste0("model_", reg_lab))
    if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

    n_panels <- length(plot_n)
    nrow_panel <- ceiling(sqrt(n_panels))
    ncol_panel <- ceiling(n_panels / nrow_panel)

    pdf(file.path(out_dir, paste0("psi_hist_reg_", reg_lab, "_gen_", target_gen, ".pdf")),
        width = 8 * ncol_panel, height = 6 * nrow_panel)
    op <- par(mfrow = c(nrow_panel, ncol_panel),
              mar = c(4, 3.8, 2.5, 1) + 0.1, oma = c(0, 0, 2.5, 0))

    # Pre-choose a color per n for consistency
    cols <- hcl.colors(length(plot_n), "Berlin")

    # Determine a shared y-maximum (in counts) across panels for nice comparison
    # We compute provisional counts per n to find max
    ymax <- 1
    provisional_counts <- vector("list", length(plot_n))
    for (i in seq_along(plot_n)) {
      n_val <- plot_n[i]
      d_n <- subset(d_reg, n == n_val)
      if (nrow(d_n) == 0) { provisional_counts[[i]] <- rep(0, length(brks)-1); next }

      if (pool_reps) {
        cnts <- hist(d_n[[value_col]], breaks = brks, plot = FALSE)$counts
      } else {
        reps <- sort(unique(d_n$rep))
        if (!length(reps)) { provisional_counts[[i]] <- rep(0, length(brks)-1); next }
        mat <- sapply(reps, function(rp) {
          hist(subset(d_n, rep == rp)[[value_col]], breaks = brks, plot = FALSE)$counts
        })
        if (is.null(dim(mat))) {
          cnts <- mat  # only one rep
        } else {
          cnts <- rowMeans(mat, na.rm = TRUE)
        }
      }
      provisional_counts[[i]] <- cnts
      ymax <- max(ymax, max(cnts, na.rm = TRUE))
    }
    # Avoid zero lower bound for log axis
    y_min_plot <- 1
    y_max_plot <- max(10, ymax)

    # Draw panels
    for (i in seq_along(plot_n)) {
      n_val <- plot_n[i]
      cnts <- provisional_counts[[i]]

      # Base frame with log y
      plot(NA, xlim = range(brks), ylim = c(y_min_plot, y_max_plot),
           xlab = "psi", ylab = "Count (log scale)", main = paste0("n = ", n_val),
           xaxt = "n", yaxt = "n", log = "y")
      axis(1)
      # y-axis with integer-ish ticks; choose nice ticks
      y_ticks <- 10 ^ seq(0, floor(log10(y_max_plot)), by = 1)
      axis(2, at = y_ticks, labels = y_ticks, las = 1)

      # Draw bars (skip zero-count bars because log-scale can't draw them)
      if (length(cnts)) {
        for (b in seq_along(cnts)) {
          cval <- cnts[b]
          if (is.na(cval) || cval <= 0) next
          xleft  <- brks[b]
          xright <- brks[b + 1]
          rect(xleft, y_min_plot, xright, cval,
               col = adjustcolor(cols[i], alpha.f = 0.7), border = NA)
        }
        # Optional outline for clarity
        # lines(rep(brks, each=2)[-c(1, length(brks)*2)],
        #       as.vector(rbind(pmax(cnts, y_min_plot), pmax(cnts, y_min_plot))),
        #       col="gray30")
      }

      # Small subtitle about pooling mode
      mtext(if (pool_reps) "pooled reps" else "avg counts across reps", side = 3, line = 0.2, cex = 0.8)
    }

    mtext(paste0("Regime: ", reg_lab, "  |  Generation: ", target_gen,
                 "  |  ", if (pool_reps) "Pooled reps" else "Averaged across reps",
                 "  |  bins=", length(brks)-1),
          outer = TRUE, cex = 1.0, line = 0.6)

    par(op)
    dev.off()
  } # end regimes
}

```


## plot distribution for different data
```{r}

# ---- Helper: get integer-named value columns ----
.value_cols_int <- function(df) {
  grep("^[0-9]+$", names(df), value = TRUE)
}

.apply_filter <- function(d, filter) {
  if (!length(filter)) return(d)
  for (nm in names(filter)) {
    val <- filter[[nm]]

    # Threshold syntax: <col>_<op> with op in {gt,ge,lt,le}
    if (grepl("_(gt|ge|lt|le)$", nm)) {
      base <- sub("_(gt|ge|lt|le)$", "", nm)
      op   <- sub("^.*_(gt|ge|lt|le)$", "\\1", nm)
      if (!(base %in% names(d))) next

      x <- suppressWarnings(as.numeric(d[[base]]))
      thr <- as.numeric(val)
      if (!is.finite(thr)) next

      keep <- switch(op,
        gt = x >  thr,
        ge = x >= thr,
        lt = x <  thr,
        le = x <= thr
      )
      keep[is.na(keep)] <- FALSE
      d <- d[keep, , drop = FALSE]

    } else if (nm %in% names(d)) {
      # Plain equality filter
      d <- d[d[[nm]] == val, , drop = FALSE]
    }
  }
  d
}

# ---- Main: average-binned line plot across replicates ---------------------
plot_rep_binned_mean_line <- function(
  df,
  filter = list(),                # e.g., list(reg="ave", n=8, shift_size=200)
  generation = 10001,             # target generation
  breaks = NULL,                  # explicit numeric vector of bin edges (preferred)
  n_bins = 50,                    # used only if 'breaks' is NULL
  xlim = NULL,                    # c(min, max); required if you use n_bins; ignored if 'breaks' given
  ylim = NULL,
  labels = list(title = "Averaged distribution",
                x = "Value",
                y = "Proportion"),
  col = "black", lwd = 2, lty = 1,
  add = FALSE,                    # if TRUE, add lines to existing plot
  show_points = FALSE,            # draw points at bin midpoints
  cex_axis = 1.2, cex_lab = 1.4, cex_main = 1.4, plot_rep = FALSE
) {
  # subset by generation and filter
  d <- df
  if (!is.null(generation) && "generation" %in% names(d)) {
    d <- d[d$generation == generation, , drop = FALSE]
  }
    d <- .apply_filter(d, filter)
  if (nrow(d) == 0) stop("No rows after applying generation/filter.")

  # identify value columns
  vcols <- .value_cols_int(d)
  if (!length(vcols)) stop("No integer-named value columns found.")

  # figure out bins
  if (!is.null(breaks)) {
    breaks <- sort(as.numeric(breaks))
    if (any(!is.finite(breaks)) || length(breaks) < 2) stop("Invalid 'breaks'.")
    x_min <- min(breaks); x_max <- max(breaks)
  } else {
    if (is.null(xlim) || length(xlim) != 2) stop("Provide 'xlim = c(min,max)' when 'breaks' is NULL.")
    x_min <- xlim[1]; x_max <- xlim[2]
    if (!is.finite(x_min) || !is.finite(x_max) || x_max <= x_min) stop("Invalid 'xlim'.")
    breaks <- seq(x_min, x_max, length.out = n_bins + 1)
  }

  # per-rep hist proportions (ignoring out-of-range values)
  reps <- sort(unique(d$rep))
  if (length(reps) == 0) stop("Column 'rep' missing or no replicates present.")

  bin_mids <- (breaks[-1] + breaks[-length(breaks)]) / 2
  M <- matrix(0, nrow = length(reps), ncol = length(bin_mids))

  row_idx <- 0
  for (r in reps) {
    row_idx <- row_idx + 1
    dr <- d[d$rep == r, , drop = FALSE]
    if (nrow(dr) == 0) next

    # pool values across all integer-named columns for this rep-row
    vals <- unlist(dr[, vcols, drop = FALSE], use.names = FALSE)
    vals <- vals[is.finite(vals)]
    # ignore out-of-range
    vals <- vals[vals >= x_min & vals <= x_max]
    if (!length(vals)) next

    # counts per bin (right-closed by default)
    h <- hist(vals, breaks = breaks, plot = FALSE, include.lowest = TRUE, right = TRUE)
    # convert to proportions per bin (sum = 1 within range)
    prop <- h$counts / sum(h$counts)
    # guard if all were NA (shouldn't happen with include.lowest & filtering)
    prop[!is.finite(prop)] <- 0
    M[row_idx, ] <- prop
  }

  # average across reps
  # (if some reps contributed zeros because of no vals, still okay)
  mean_prop <- colMeans(M, na.rm = TRUE)

  if (!add) {
    par(cex.axis = cex_axis, cex.lab = cex_lab, cex.main = cex_main)
    if (is.null(ylim)){
        if (plot_rep) ymax <- max(c(mean_prop, M), na.rm = TRUE)
        else ymax <- max(mean_prop, 1e-12)
        plot(bin_mids, mean_prop, type = "l",
            xlab = labels$x, ylab = labels$y,
            main = labels$title,
            xlim = c(x_min, x_max),
            ylim = c(0, ymax))
    } else {
        plot(bin_mids, mean_prop, type = "l",
            xlab = labels$x, ylab = labels$y,
            main = labels$title,
            xlim = c(x_min, x_max),
            ylim = ylim)
    }
  }
if (plot_rep) {
    rep_col <- adjustcolor(col, alpha.f = 0.3)
    for (ii in seq_len(nrow(M))) {
      yi <- M[ii, ]
      if (all(!is.finite(yi))) next
      lines(bin_mids, yi, col = rep_col, lwd = lwd, lty = lty)
    }
  }
  lines(bin_mids, mean_prop, col = col, lwd = lwd, lty = lty)
  if (show_points) points(bin_mids, mean_prop, pch = 16, col = col)

  # return the summary invisibly
  invisible(data.frame(mid = bin_mids, mean_prop = mean_prop))
}



```



# plotting function for trajectory
```{r}
# ---------- Main plotting function ----------
plot_summary_multi_by_psi_ticks <- function(summary_stat_df,
                                            out_subfolder = "summary_multi_by_psi_ticks",
                                            regimes = NULL,
                                            column_to_plot = "dif_z_opt",
                                            col = NULL) {
    if (!dir.exists(file.path(base_plot_folder, out_subfolder))) {
        dir.create(file.path(base_plot_folder, out_subfolder), recursive = TRUE)
    }

    for (reg_lab in regimes) {
        df_reg <- subset(summary_stat_df, reg == reg_lab)
        if (nrow(df_reg) == 0) next

        out_dir <- file.path(base_plot_folder, out_subfolder, paste0("model_", reg_lab))
        if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

        shift_keys <- c(paste0("shift=", plot_shift_sizes))
        all_vals <- plot_psi 
        if (is.null(col)){
            mean_cols <- hcl.colors(length(all_vals), hcl_color_palette)
        }else {
            mean_cols <- col
        }

        for (n_val in plot_n) {
            df_n <- subset(df_reg, n == n_val)
            if (nrow(df_n) == 0) next

            for (sk in shift_keys) {
                df_group <- subset(df_n, shift_size == as.numeric(sub("shift=", "", sk)))
                if (nrow(df_group) == 0) next

                # Y-limits across panels
                y_min <- Inf; y_max <- -Inf
                for (val in all_vals) {
                    df_p <- subset(df_group, psi == val & tick %in% tick_seq)
                    
                    if (nrow(df_p) == 0) next
                    s <- .compute_series(df_p, tick_seq, column_to_plot)
                    y_all <- c(unlist(s$reps, use.names = FALSE), s$mean)
                    y_all <- y_all[is.finite(y_all)]
                    if (length(y_all)) {
                        y_min <- min(y_min, y_all)
                        y_max <- max(y_max, y_all)
                    }
                }
                if (!is.finite(y_min) || !is.finite(y_max) || y_min == y_max) {
                    y_min <- 0; y_max <- 1
                }

                title_suffix <- paste0("shift_size = ", as.numeric(sub("shift=", "", sk)))
                out_name <- paste0("n_", n_val, "_", gsub("[ =]", "", title_suffix), ".png")
                png(file.path(out_dir, out_name), width = 2500, height = 1800, res = 200)

                par(cex.axis = 1.6, cex.lab = 2.0, cex.main = 1.0, mar = c(4.5, 6, 3, 1) + 0.1)
                plot(NA, xlim = range(tick_seq), ylim = c(y_min, y_max),
                    xlab = "Generation", ylab = "Distance to Optimum", 
                    main = paste0("Trajectory over 100 generations | model = ",
                            reg_lab, " | n = ", n_val, " | ", title_suffix),
                    xaxt = "n")
            
                ticks <- list(0, 50, 100, 200)
                at_ticks <- list(9999, 10050, 10100, 10200)
                axis(1, at = at_ticks, labels = ticks)

                for (i in seq_along(all_vals)) {
                    val <- all_vals[i]
                    mean_col <- mean_cols[i]
                    df_p <- subset(df_group, psi == val & tick %in% tick_seq)
                    
                    if (nrow(df_p) == 0) next

                    s <- .compute_series(df_p, tick_seq, column_to_plot)
                    # Replicate series
                    if (plot_reps & length(s$reps)) {
                        rep_col <- adjustcolor(mean_col, , alpha.f = 0.35)

                        for (r in seq_along(s$reps)) {
                            lines(tick_seq, s$reps[[r]], col = rep_col, lwd = 1.5)
                            points(tick_seq, s$reps[[r]], pch = 16, cex = 0.5, col = rep_col)
                        }
                    }
                    # Across-rep mean (already with dynamic 9999 substitution)
                    lines(tick_seq, s$mean, col = mean_col, lwd = 1.5)
                    points(tick_seq, s$mean, pch = 16, cex = 1.5, col = mean_col)

                    # ---- Exponential-decay fit (exclude tick 9999 from fitting) ----
                    if (plot_exp_fit & is.finite(min(s$mean, na.rm = TRUE)) && is.finite(max(s$mean, na.rm = TRUE))) {
                        present <- is.finite(s$mean) & (tick_seq != 9999)
                        x_fit <- tick_seq[present]
                        y_fit <- s$mean[present]
                        if (length(x_fit) >= 5 && diff(range(y_fit)) > 0) {
                            fit <- .fit_exp_decay(x_fit, y_fit)
                            if (isTRUE(fit$success)) {
                                lines(fit$x_fit, fit$y_fit, col = "black", lwd = 2, lty = 2)

                k <- fit$params["k"]
                tau <- if (is.finite(k) && k > 0) 1/k else NA_real_
                t_half <- if (is.finite(k) && k > 0) log(2)/k else NA_real_

                legend("bottomleft", inset = 0.02,
                       legend = c(
                         "Exp fit: y = c0 + c1*e^{-k(x - t0)}",
                         paste0("c0=", .fmt(fit$params["c0"]), ", c1=", .fmt(fit$params["c1"])),
                         paste0("k=", .fmt(k), "  (tau= ", .fmt(tau), ", t1/2= ", .fmt(t_half), ")"),
                         paste0("R^2=", .fmt(fit$r2)),
                         "Note: tick 9999 excluded from fit"
                       ),
                       col = c(NA, "red", "red", "red", NA),
                       lty = c(NA, 2, 2, 2, NA), lwd = c(NA, 2, 2, 2, NA),
                       bty = "n", cex = 0.78, text.col = c("black","red","red","red","black"))
                            }
                        }
                    }
                }

                # legend_vals <- paste0(expression("psi="), all_vals)
                leg_expr <- as.expression(lapply(all_vals, function(v) bquote(psi == .(v))))
                
                if (plot_exp_fit) {
                    legend(
                    "topright", inset = 0.02,
                    legend = c(leg_expr, "Exp. decay fit"),
                    col    = c(mean_cols,  "black"),
                    lty    = c(rep(1, length(legend_vals)), 1),
                    lwd    = c(rep(1, length(legend_vals)), 2),
                    pch    = c(rep(16, length(legend_vals)), 16),
                    pt.cex = c(rep(0.5, length(legend_vals)), 0.9),
                    bty = "n", cex = 0.85
                    )
                } else {
                    legend(
                    "topright", inset = 0.02,
                    legend = leg_expr,
                    col    = mean_cols,
                    lty    = 1,
                    lwd    = 2,
                    pch    = 20,
                    pt.cex = 1.0,
                    bty = "n", cex = 2.2
                    )
                }

                dev.off()
            }
        }
    }
}

```

```{r}
plot_psimean_faceted_by_spsi <- function(df,
                                         base_plot_folder,
                                         regs = NULL,
                                         ns    = NULL,
                                         shift_sizes = NULL,
                                         file_subdir = "psimean",
                                         mean_line_col = "black",
                                         mean_lwd      = 4,
                                         mean_lty      = 5,
                                         col_gt        = "#0072B2",  # > spsi
                                         col_eq        = "#7B1FA2",  # = spsi
                                         col_lt        = "#D55E00",  # < spsi
                                         rep_alpha     = 0.55,
                                         point_cex     = 0.7,
                                         tol           = 1e-10) {

  needed <- c("tick","psi_mean","psi_sd","rep","reg","n","shift_size","spsi")
  missing_cols <- setdiff(needed, names(df))
  if (length(missing_cols)) stop("Missing columns: ", paste(missing_cols, collapse=", "))

  d <- df
  d$tick       <- suppressWarnings(as.integer(d$tick))
  d$rep        <- suppressWarnings(as.integer(d$rep))
  d$n          <- suppressWarnings(as.integer(as.character(d$n)))
  d$shift_size <- suppressWarnings(as.integer(as.character(d$shift_size)))
  d$psi_mean   <- suppressWarnings(as.numeric(d$psi_mean))
  d$psi_sd     <- suppressWarnings(as.numeric(d$psi_sd))
  d$spsi       <- suppressWarnings(as.numeric(d$spsi))
  d <- d[is.finite(d$tick) & is.finite(d$rep) & is.finite(d$psi_mean) &
           !is.na(d$reg) & is.finite(d$n) & is.finite(d$shift_size) & is.finite(d$spsi), ]

  if (!is.null(regs))        d <- d[d$reg %in% regs, ]
  if (!is.null(ns))          d <- d[d$n %in% ns, ]
  if (!is.null(shift_sizes)) d <- d[d$shift_size %in% shift_sizes, ]

  out_dir <- file.path(base_plot_folder, file_subdir)
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

  .grid_dims <- function(k) { if (k <= 1) c(1,1) else { nc <- ceiling(sqrt(k)); nr <- ceiling(k/nc); c(nr,nc) } }

  combos <- unique(d[, c("reg","n","shift_size")])
  combos <- combos[order(combos$reg, combos$n, combos$shift_size), ]

  for (ii in seq_len(nrow(combos))) {
    reg_i  <- combos$reg[ii]
    n_i    <- combos$n[ii]
    sz_i   <- combos$shift_size[ii]

    sub <- d[d$reg == reg_i & d$n == n_i & d$shift_size == sz_i, ]
    if (nrow(sub) == 0) next

    spsi_vals <- sort(unique(sub$spsi))
    K <- length(spsi_vals); dims <- .grid_dims(K)

    # x-range can stay common within file; y-range will be per-panel
    x_range <- range(sub$tick, na.rm = TRUE)

    png_path <- file.path(out_dir, paste0(reg_i, "_", sz_i, "_", n_i, ".png"))
    png(png_path, width = 1800, height = max(1000, 500 * dims[1]), res = 150)
    op <- par(mfrow = dims, mar = c(4,4,3.5,1.5), mgp = c(2.2, 0.7, 0))

    add_legend <- TRUE

    for (sval in spsi_vals) {
      panel <- sub[sub$spsi == sval, ]
      if (nrow(panel) == 0) { plot.new(); title(main = paste0("spsi = ", format(sval))); next }

      # ----- Per-panel centered y-limits around spsi -----
      # consider all points in the panel (all reps)
      y_min <- min(panel$psi_mean, na.rm = TRUE)
      y_max <- max(panel$psi_mean, na.rm = TRUE)
      max_dev <- max(abs(c(y_min - sval, y_max - sval)))
      if (!is.finite(max_dev) || max_dev == 0) max_dev <- 1e-6
      pad <- 0.05 * max_dev
      y_lim <- sval + c(-max_dev - pad, max_dev + pad)

      plot(NA, xlim = x_range, ylim = y_lim,
           xlab = "tick", ylab = expression(psi[mean]),
           main = bquote(reg==.(reg_i) * ", n=" * .(n_i) * ", shift=" * .(sz_i) * ", spsi=" * .(sval)))

      # Rep points colored by comparison to spsi
      reps <- sort(unique(panel$rep))
      col_gt_a <- adjustcolor(col_gt, rep_alpha)
      col_eq_a <- adjustcolor(col_eq, rep_alpha)
      col_lt_a <- adjustcolor(col_lt, rep_alpha)

      for (r in reps) {
        pr <- panel[panel$rep == r, c("tick","psi_mean")]
        pr <- pr[order(pr$tick), ]
        diff <- pr$psi_mean - sval
        is_eq <- abs(diff) <= tol
        is_gt <- diff >  tol
        is_lt <- diff < -tol

        if (any(is_lt)) points(pr$tick[is_lt], pr$psi_mean[is_lt], pch = 16, cex = point_cex, col = col_lt_a)
        if (any(is_eq)) points(pr$tick[is_eq], pr$psi_mean[is_eq], pch = 16, cex = point_cex, col = col_eq_a)
        if (any(is_gt)) points(pr$tick[is_gt], pr$psi_mean[is_gt], pch = 16, cex = point_cex, col = col_gt_a)
      }

      # Mean across reps (black dashed thick)
      mdat <- aggregate(psi_mean ~ tick, data = panel, FUN = mean)
      mdat <- mdat[order(mdat$tick), ]
      lines(mdat$tick, mdat$psi_mean, col = mean_line_col, lwd = mean_lwd, lty = mean_lty)

      # Reference line at spsi (center line)
      abline(h = sval, lty = 3, col = adjustcolor("gray20", 0.7))
      if (add_legend){
        legend("topleft",
              legend = c(expression(psi[mean] < spsi),
                          expression(psi[mean] == spsi),
                          expression(psi[mean] > spsi),
                          "mean across reps"),
              pch = c(16,16,16, NA),
              lwd = c(NA,NA,NA, mean_lwd),
              lty = c(NA,NA,NA, mean_lty),
              col = c(col_lt, col_eq, col_gt, mean_line_col),
              bty = "n", cex = 0.9)
        add_legend <- FALSE
      }
    }

    par(op); dev.off()
    message("Wrote: ", png_path)
  }
}


```



